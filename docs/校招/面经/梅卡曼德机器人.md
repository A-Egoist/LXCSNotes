# 梅卡曼德机器人

HR 说先实习再考虑转正



## 技术二面

1.   自我介绍

2.   C++ 的强制转换类型

3.   这几种强制类型转换分别适用的场景

4.   dynamic_cast 的实现原理是什么？

5.   请解释 C++ 的虚表

6.   C++ 的智能指针有哪些？它们的区别是什么？

7.   std::move 的原理是什么

8.   左值和右值的区别

9.   右值的引入是为了解决什么问题

10.   线程的同步方式有哪些

11.   Docker 的实现原理是什么？

12.   SQL 的连接查询语句

13.   实现一个支持多线程的日志类
      ```cpp
      #include <iostream>
      #include <queue>
      #include <string>
      #include <mutex>
      #include <fstream>
      #include <thread>
      #include <condition_variable>
      
      // Logger 类遵循单例模式
      class Logger {
      public:
          // 获取单例实例
          static Logger& getInstance() {
              static Logger instance;
              return instance;
          }
      
          // 初始化Logger，设置文件名和模式
          void init(const std::string& filename, bool async) {
              filename_ = filename;
              async_ = async;
      
              if (async_) {
                  // 如果是异步模式，则启动一个后台线程来处理日志写入
                  // 使用unique_lock确保在线程启动前文件流已打开
                  std::unique_lock<std::mutex> lock(queue_mutex_);
                  file_.open(filename_, std::ios::app);
                  if (!file_.is_open()) {
                      std::cerr << "Error: Failed to open log file " << filename_ << std::endl;
                      return;
                  }
                  // 将线程包装在一个 lambda 函数中，并将其设置为分离式，使其独立运行
                  worker_thread_ = std::thread(&Logger::worker_thread_func, this);
              } else {
                  // 如果是同步模式，每次写入时都打开文件并追加
                  // 这种模式效率较低，主要用于演示
              }
          }
      
          // 析构函数：确保在程序退出时，后台线程已安全结束，并清空所有剩余日志
          ~Logger() {
              if (async_) {
                  {
                      std::unique_lock<std::mutex> lock(queue_mutex_);
                      stop_thread_ = true; // 设置停止标志
                  }
                  // 唤醒工作线程，让它知道需要退出了
                  cond_var_.notify_one();
      
                  // 等待工作线程完成其任务并退出
                  if (worker_thread_.joinable()) {
                      worker_thread_.join();
                  }
      
                  // 关闭文件流
                  if (file_.is_open()) {
                      file_.close();
                  }
              }
          }
      
          // 写入日志的核心方法
          void write(const std::string& str) {
              if (async_) {
                  // 异步模式：将日志消息推入队列并通知工作线程
                  {
                      std::lock_guard<std::mutex> lock(queue_mutex_);
                      queue_.push(str);
                  }
                  cond_var_.notify_one(); // 唤醒一个等待中的工作线程
              } else {
                  // 同步模式：直接将日志消息写入文件
                  // 每次写入都打开和关闭文件，性能较低
                  std::lock_guard<std::mutex> lock(queue_mutex_);
                  std::ofstream sync_file(filename_, std::ios::app);
                  if (sync_file.is_open()) {
                      sync_file << str << std::endl;
                      sync_file.close();
                  } else {
                      std::cerr << "Error: Failed to open log file in sync mode." << std::endl;
                  }
              }
          }
      
      private:
          // 私有构造函数，防止外部实例化
          Logger() = default;
          // 禁止拷贝和赋值
          Logger(const Logger&) = delete;
          Logger& operator=(const Logger&) = delete;
      
          // 后台工作线程的执行函数
          void worker_thread_func() {
              while (true) {
                  std::unique_lock<std::mutex> lock(queue_mutex_);
                  // 等待直到队列不为空或需要停止线程
                  cond_var_.wait(lock, [this] {
                      return !queue_.empty() || stop_thread_;
                  });
      
                  // 检查停止标志，如果队列为空则退出
                  if (stop_thread_ && queue_.empty()) {
                      break;
                  }
      
                  // 将队列中的所有消息一次性写入文件，然后清空队列
                  while (!queue_.empty()) {
                      file_ << queue_.front() << std::endl;
                      queue_.pop();
                  }
                  // 立即刷新缓冲区，确保日志被写入磁盘
                  file_.flush();
              }
          }
      
          std::queue<std::string> queue_;
          std::mutex queue_mutex_;
          std::condition_variable cond_var_;
          std::string filename_;
          bool async_ = false;
          bool stop_thread_ = false;
          std::thread worker_thread_;
          std::ofstream file_; // 文件流作为成员变量，仅在初始化时打开一次
      };
      ```

14.   反问环节

https://ncn4yely6co0.feishu.cn/minutes/obcnthpf556n2c1onw6vb966



## 技术一面

1.   自我介绍
2.   项目经历
3.   是否实现过导出PDF检测报告的工作
4.   `std::atomic` 中的 `compare_exchange_weak` 和 `compare_exchange_strong` 的应用场景，expected 参数的作用，为什么有这个参数
5.   `std::map` 和 `std::unordered_map` 的时间复杂度
6.   `static` 声明的变量存储在哪个区域？
7.   能讲讲一个可执行程序的启动过程吗？
8.   你了解交叉编译吗？
9.   gdb 的一些常用操作
10.   编程的时候 ai 工具用得多吗？
11.   正权边的最短路径用什么算法？
12.   归并排序的原理是什么？

```cpp
#include <iostream>
#include <vector>
#include <queue>

struct Node
{
    int i, j, value;
    bool operator<(const Node& other) const {
        return value > other.value;
    }
};

std::vector<int> regroup(std::vector<std::vector<int>>& inputs, int maxcount) {
    std::vector<int> res;
    std::priority_queue<Node> min_heap;
    for (int i = 0; i < inputs.size(); ++ i) {
        if (inputs[i].size() > 0) min_heap.push({i, 0, inputs[i][0]});
    }

    int count = 0;
    while (count < maxcount) {
        ++ count;
        auto temp = min_heap.top();
        min_heap.pop();

        res.push_back(temp.value);
        int curr_i = temp.i;
        int next_j = temp.j + 1;
        if (next_j < inputs[curr_i].size()) min_heap.push({curr_i, next_j, inputs[curr_i][next_j]});
    }
    return res;
}

int main() {
    std::vector<std::vector<int>> arr = {{1, 5, 6}, {-1, -1, 0, 0, 3}, {6, 7}, {0, 2, 2, 3}};
    auto res = regroup(arr, 13);
    for (auto num : res) std::cout << num << " ";
    std::cout << std::endl;

    return 0;
}
```

输入：

>   {{1，5，6}
>   {-1，-1，0，0，3}，
>   {6，7}，
>   {0，2，2，3}}



13.   反问环节：

视觉软件开发
3D相机 软硬件
Qt 客户端
点云
无代码，类UE蓝图 + 脚本语言

迭代开发
开发流程

在线测量 - 蓝斯
产品官网 --> 产品业务线



https://ncn4yely6co0.feishu.cn/minutes/obcnso381u25y1vkb24b56sa



## HR 电话面



