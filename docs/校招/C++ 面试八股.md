# C++ 面试八股



### 程序运行的步骤

源文件

:arrow_down:

预编译 (Pre-Processor)：将头文件编译，进行宏替换，输出.i文件

:arrow_down:

编译 (Compiler)：将其转化为汇编语言文件，主要做词法分析，语义分析以及检查错误，检查无误后将代码翻译成汇编语言，生成.s文件

:arrow_down:

汇编 (Assembler)：汇编器将汇编语言文件翻译成机器语言，生成.o文件

:arrow_down:

链接 (Linker)：将目标文件和库链接到一起，生成可执行文件.exe

:arrow_down:

可执行文件

[为什么有些项目会使用多种编程语言？](https://www.bilibili.com/video/BV1aXbXzfEsM/?spm_id_from=333.1245.0.0&vd_source=f4cc25a44af6631d6f4db023b3bb88e4)



### TCP 三次握手四次挥手



### C++ 中强制类型转换和 C 语言类型转换的区别



对比表格

| 转换类型   | C 风格            | C++ 风格                       | 安全性     |
| ---------- | ----------------- | ------------------------------ | ---------- |
| 数值转换   | `(type)value`     | `static_cast<type>(value)`     | 相同       |
| 指针转换   | `(type*)ptr`      | `dynamic_cast<type*>(value)`   | C++ 更安全 |
| const 转换 | `(type*)constPtr` | `const_cast<type*>(constPtr)`  | 相同       |
| 重新解释   | `(type*)ptr`      | `reinterpret_cast<type*>(ptr)` | 相同       |



### class 和 struct 的区别

在 C++ 中，`struct` 和 `class` 都用于定义自定义数据类型，它们的核心功能几乎相同，主要区别在于**默认访问权限**和**默认继承方式**。

class默认继承的是private继承，struct默认是public继承。

1.   默认访问权限不同：
     ```cpp
     // struct 默认所有成员为 public
     struct Point {
         int x;     // 默认为 public
         int y;     // 默认为 public
     };
     
     // class 默认所有成员为 private
     class Circle {
         double r;  // 默认为 private
     public:
         double area() { return 3.14 * r * r; }
     };
     ```

2.   默认继承方式不同：
     ```cpp
     struct Base { int data; };
     
     // struct 继承默认为 public
     struct DerivedStruct : Base { 
         // 可直接访问 Base::data (public)
     };
     
     class DerivedClass : Base { 
         // 默认为 private 继承，Base::data 不可直接访问
     };
     ```



class 还可用于**定义模板参数**，但是关键字 struct 不能同于定义模板参数，C++ 保留 struct 关键字，原因是保证与 C 语言的向下兼容性，为了保证百分百的与 C 语言中的 struct 向下兼容，，C++ 把最基本的对象单元规定为 class 而不是 struct，就是为了避免各种兼容性的限制。



### 引用和指针的区别

1.   引用必须在声明时初始化，指针可以不需要初始化
     ```cpp
     #include <iostream>
     
     int main() {
         int value = 10;
         int* p;  // 不初始化
         p = nullptr;  // 将指针设置为空
         p = &value;  // 给指针赋值
         // int& ref_value;  // 报错
         int& ref_value = value;
     
         return 0;
     }
     ```

2.   指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名，引用本身并不存储地址，而是在底层通过指针来实现对原变量的访问

3.   引用被创建之后，就不可以进行更改，指针可以更改

4.   不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。



### 引用在声明的时候可以不初始化吗

引用在声明的时候必须初始化



### 左值引用和右值引用

在 C++ 中，**左值引用（lvalue reference）** 和 **右值引用（rvalue reference）** 是两种不同的引用类型，它们的主要区别在于 **绑定对象的类别（左值 or 右值）** 和 **用途（拷贝优化 or 资源转移）**。

**左值**是指既能出现在等号左边也能出现在等号右边的变量(或表达式)，**右值**则只能出现在等号右边。

*   **左值（lvalue）**：可以取地址、有名字的持久对象（如变量、函数返回的引用等）。 **绑定到左值（lvalue）** 的引用，用 `&` 表示。

    ```cpp
    int x = 10;  
    int& lref = x;  // ✅ 左值引用绑定左值
    lref = 20;      // 修改 x 的值
    
    int& bad = 42;  // ❌ 错误：不能绑定到右值（临时对象）
    ```

*   **右值（rvalue）**：临时对象、即将销毁的对象（如字面量、`std::move` 后的对象）。 **绑定到右值（rvalue）** 的引用，用 `&&` 表示。

    ```cpp
    int&& rref = 42;          // ✅ 右值引用绑定右值
    int x = 10;
    int&& rref2 = std::move(x);  // ✅ 使用 std::move 转为右值
    
    int&& bad = x;            // ❌ 错误：不能直接绑定左值
    ```



### 指针常量和常量指针的区别

`const` 默认修饰左侧的内容，如果左侧无内容，则修饰右侧的内容

```cpp
int const* ptr;  // 指向常量整型的指针 --> 指针可以变，指向的内容不可以变
const int* ptr;  // 指向常量整型的指针 --> 指针可以变，指向的内容不可以变
int* const ptr;  // 指向整型的常量指针 --> 指针不可以变，指向的内容可以变
const int* const ptr;  // 指向常量整型的常量指针 --> 指针和指向的内容都不可以变
```

[[C/C++] const int* 与 int const* 的区别](https://blog.csdn.net/tengqi200/article/details/115441616)



### C++ 中的原子变量

C++ 中 `std::atomic` 用于实现原子操作，是 C++11 中引入的新特性。

多个线程可以对同一个变量进行读写操作，不会导致数据竞争或中间状态，也不需要锁的保护，一定程度上简化了代码编写，性能也会有提高。

1）什么是原子操作：

2）如何使用 `std::atomic`：

3）底层实现：`std::atomic` 通过 CPU 提供的原子指令来实现这些不可分割的操作。现代 CPU 会提供一组指令，比如 CMPXCHG, XADD 等来实现原子的读或写。

4）内存序约束：C++ 提供了多种内存序约束，比如 memory_order_relaxed, memory_order_acquire, memory_order_release 等。这些约束让你可以更好地控制程序的内存可见性和行为。
例如，memory_order_relaxed 只保证原子性，但不提供任何同步或顺序保证，而 memory_order_acquire 和 memory_order_release 则提供更严格的同步机制。
atomic 默认使用的是 memory_order_seq_cst，也就是最严格的内存序约束，既保证原子性，又提供了同步顺序保证。详见 cppreference。

5）和锁比较：虽然 `std::atomic` 可以在某些场景下替代锁，但它并不是万能的。锁在某些复杂场景下仍然是不可替代的。原子操作更适合一些基本的计数器或标志位，而对于复杂的数据结构，锁的使用仍是较优选择。

6）性能：使用原子操作通常比使用锁要快，因为锁涉及到上下文切换和操作系统调度，而原子操作都是硬件级别的操作。经过优化的原子操作可以使得你的程序在多线程环境下有更好的性能表现。



### map 和 unordered_map 的区别

|              | map                                | unordered_map                                              |
| ------------ | ---------------------------------- | ---------------------------------------------------------- |
| 底层数据结构 | 红黑树                             | 哈希表                                                     |
| 时间复杂度   | O(log n)                           | 平均O(1)，最坏情况下(所有元素都在同一个哈希桶中)退化为O(n) |
| 空间复杂度   | 相对较低                           | 相对较高，因为哈希表需要分配额外的空间来存储和处理冲突     |
| 元素顺序     | 有序，按照键排序                   | 无序                                                       |
| 适用场景     | 有序，对时空复杂度严格要求O(log n) | 不关心顺序，需要更快的插入、删除和查询操作                 |



### 介绍红黑树

[【数据结构】史上最好理解的红黑树讲解，让你彻底搞懂红黑树](https://blog.csdn.net/cy973071263/article/details/122543826)



### 常见的排序算法有哪些？

| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 | 适用场景                     |
| ------------ | -------------- | -------------- | ---------- | ------ | ---------------------------- |
| **冒泡排序** | O(n²)          | O(n²)          | O(1)       | 稳定   | 教学用途，小规模数据         |
| **选择排序** | O(n²)          | O(n²)          | O(1)       | 不稳定 | 简单但低效                   |
| **插入排序** | O(n²)          | O(n²)          | O(1)       | 稳定   | 小规模或基本有序数据         |
| **希尔排序** | O(n log n)     | O(n²)          | O(1)       | 不稳定 | 改进的插入排序，中等规模数据 |
| **归并排序** | O(n log n)     | O(n log n)     | O(n)       | 稳定   | 大数据量，外部排序           |
| **快速排序** | O(n log n)     | O(n²)          | O(log n)   | 不稳定 | 通用最快，内存排序           |
| **堆排序**   | O(n log n)     | O(n log n)     | O(1)       | 不稳定 | 无需额外空间，优先级队列     |
| **计数排序** | O(n + k)       | O(n + k)       | O(k)       | 稳定   | 整数范围小且密集的数据       |
| **桶排序**   | O(n + k)       | O(n²)          | O(n + k)   | 稳定   | 均匀分布的数据               |
| **基数排序** | O(n × k)       | O(n × k)       | O(n + k)   | 稳定   | 多关键字排序（如字符串）     |



### I/O模型有哪些？

| I/O 模型         | 阻塞？ | 同步？ | 核心机制              | 适用场景             |
| ---------------- | ------ | ------ | --------------------- | -------------------- |
| **阻塞 I/O**     | 是     | 同步   | 线程全程等待          | 简单低并发程序       |
| **非阻塞 I/O**   | 否     | 同步   | 线程轮询检查          | 需兼顾其他任务的程序 |
| **I/O 多路复用** | 是[^1] | 同步   | `select`/`epoll` 监听 | 高并发网络服务       |

[^1]: I/O 多路复用中，`select`/`epoll` 调用本身是阻塞的，但可监听多个 I/O。



*   阻塞 I/O
    *   调用 I/O 操作时，线程一直等待，直到数据就绪或操作完成。
    *   期间线程无法执行其他任务（CPU 闲置）。
*   非阻塞 I/O
    *   调用 I/O 操作时，若数据未就绪，立即返回错误（如 EWOULDBLOCK）。
    *   线程需轮询检查数据是否就绪（消耗 CPU）。
    *   线程可执行其他任务（但需主动轮询）。
*   I/O 多路复用
    *   使用 select/poll/epoll等系统调用，单线程监听多个 I/O 事件。
    *   当某个 I/O 就绪时，通知线程处理。



### 常见的多路复用机制

#### `select`

*   **跨平台**：支持所有主流操作系统（Linux/Windows/macOS）。
*   **基于轮询**：通过遍历文件描述符集合（`fd_set`）检查就绪状态。
*   限制：
    *   单个进程最多监听 **1024** 个文件描述符（FD）。
    *   每次调用需**全量拷贝**`fd_set` 到内核。
*   缺点
    *   O(n) 时间复杂度：每次遍历所有 FD，性能随 FD 数量线性下降。
    *   重复初始化：每次调用需重新设置 `fd_set`。

```cpp
```



#### `poll`

*   改进 `select` 的 FD 数量限制，使用**链表**存储 FD（理论无上限）。
*   仍需要**遍历所有 FD** 检查就绪状态（O(n) 时间复杂度）。



#### `epoll`

*   Linux
*   **事件驱动**：内核通过**回调机制**直接通知就绪的 FD，无需遍历（O(1) 时间复杂度）。
*   **高效内存**：使用**红黑树**管理 FD，支持**水平触发（LT）**和**边缘触发（ET）**模式。

**核心函数**

*   `epoll_create()`：创建 epoll 实例。
*   `epoll_ctl()`：添加/修改/删除监听的 FD。
*   `epoll_wait()`：等待就绪事件。

```cpp
```



**触发模式**

*   水平触发：只要 FD 可读/可写，epoll_wait() 会持续通知（默认模式，类似 poll）。
*   边沿触发：仅在 FD 状态变化时通知一次（需一次性处理完数据，否则可能丢失事件）。

**优点**

*   高性能：支持百万级并发（如 Nginx、Redis）。
*   低开销：无需每次调用传递所有 FD。





### 读写锁

多线程环境下对共享资源的读多写少场景，使用读写锁正适合，它通过区分读操作和写操作，可以显著提高并发性能。

*   读锁：多个线程可同时持有读锁（共享访问）。
*   写锁：仅一个线程能持有写锁，且期间不允许任何读锁或其他写锁（独占访问）。

优势：

*   读操作不互斥，适合读多写少的场景（如缓存、数据库）。
*   写操作独占资源，避免数据竞争。

![img](https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2024/202508071125294.jpeg)



### 读饥饿

<img src="https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2024/202508071125819.jpeg" alt="img" style="zoom:50%;" />

读饥饿是读写锁中的一种现象，指写线程因读线程持续占用锁而长时间无法获取写锁，导致写操作被“饿死”（无法执行）。这种现象在高并发读场景下很常见。

原因：

*   多个读线程频繁获取读锁（共享访问）。
*   写线程尝试获取写锁时，必须等待所有读锁释放。
*   若读锁的获取是连续的（无间隙），写线程将无限等待。

危害：

*   数据更新延迟：写操作无法执行，导致数据长时间不更新。
*   系统响应下降：写线程阻塞可能引发超时或死锁。
*   公平性破坏：违背“先来先服务”原则。

解决方案：

*   公平读写锁：通过队列或优先级机制，保证写锁请求不会被后续读锁插队。比如一旦有写锁请求，后续读锁必须等待写锁完成。
*   限制读锁持有时间：设置读锁的最大持有时间，超时后自动释放。
*   避免长期持有读锁：将长耗时读操作拆分为多个短操作，间歇释放锁。



### 什么是三大范式?



## malloc/free V.S. new/delete

### malloc 的内存分配的方式，有什么缺点？

`malloc` 和 `free` 是 C 语言中用于在堆上分配和释放内存的标准库函数。

**内存分配**

`malloc` 向操作系统请求内存，根据系统平台和库实现的不同，它可以使用 `brk()` 和 `mmap()` 两种方式来从操作系统请求内存。

-   小于 `128KB` 用 `brk()` 系统调用从堆分配内存，实现方式：将堆顶指针向高地址移动，获取内存空间，如果使用free释放空间，并不会将内存归还给操作系统，而是会缓存在malloc的内存池中，待下次使用。
-   大于 `128KB` 用 `mmap()` 系统调用在文件映射区域分配内存，实现方式：使用私有匿名映射的方式，在文件映射区分配一块内存，也就是从文件映射区拿了一块内存，free释放内存的时候，会把内存归还给操作系统，内存得到真正释放。

**缺点**：容易造成内存泄漏和过多的内存碎片，影响系统正常运行，还得注意判断内存是否分配成功，而且内存释放后（使用free函数之后指针变量p本身保存的地址并没有改变），需要将p的赋值为NULL拴住野指针。



**为什么不全用 `mmap()` 来分配内存？**

因为向操作系统申请内存的时候，是要通过系统调用的，执行系统调用要进入内核态，然后再回到用户态，状态的切换会耗费不少时间，所以申请内存的操作应该避免频繁的系统调用，如果都使用mmap来分配内存，等于每次都要执行系统调用。另外，因为mmap分配的内存每次释放的时候都会归还给操作系统，于是每次mmap分配的虚拟地址都是缺页状态，然后在第一次访问该虚拟地址的时候就会触发缺页中断。



**为什么不全用 `brk()` 来分配内存？**

如果全部使用brk申请内存那么随着程序频繁的调用malloc和free，尤其是小块内存，堆内将产生越来越多的不可用的内存碎片。



**内存管理**

`malloc` 使用一种数据结构（通常是链表或树形结构）来管理已分配和未分配的内存块。当用户请求内存时，`malloc` 首先在内存管理数据结构中查找一个合适大小的空闲内存块。如果找到合适的内存块，`malloc` 会将其从空闲列表中移除并返回给用户。如果没有找到合适的内存块，`malloc` 会向操作系统请求更多的内存。



### malloc 只分配内存，不调用构造函数？





### 什么是内存泄漏，产生的原因？



### 匿名函数的本质是什么？他的优点是什么？

匿名函数**本质**上是一个对象，在其定义的过程中会创建出一个栈对象，内部通过重载 `()` 符号实现函数调用的外表。

**优点**：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。



4.   



### C++ 面向对象的三大特性

在 C++ 面向对象的程序设计方法中，面向对象的三大特性：

1.   封装：将具体实现过程和数据封装成一个类，只能通过接口进行访问，降低耦合性，使类成为一个具有内部数据的自我隐藏能力、功能独立的软件模块。意义：保护或防止代码在无意之中被破坏，保护类中的成员，不让类中以外的程序直接访问或者修改，只能通过提供的公共接口访问。
2.   继承：子类继承父类的特征和行为，复用了基类的**全体数据**和**成员函数**，具有从基类复制而来的**数据成员**和**成员函数**（基类私有成员可被继承，但是无法被访问），其中**构造函数、析构函数、友元函数、静态数据成员、静态成员函数**都不能被继承。基类中成员的访问方式只能决定派生类能否访问它们。增强了代码耦合性，当父类中的成员变量或者类本身被 `final` 关键字修饰时，修饰的类不能被继承，修饰的成员函数不能重写或修改。意义：基类的程序代码可以被派生类服用，提高了软件复用的效率，缩短了软件开发的周期。
3.   多态：不同继承类的对象对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现形式。意义：对已存在的代码具有可替代性，对代码具有可扩充性，新增子类不会影响已存在类的各种性质，在程序中体现了灵活多样的操作，提高了使用效率，简化了对应用代码的编写和修改过程。



## 头文件

[米哈游C++一面：头文件相关的面试题、如何解决头文件循环包含的问题？](https://www.bilibili.com/video/BV1SvPueyEjG?spm_id_from=333.1245.0.0)

总结：

*   循环依赖 $\to$ 前置声明
*   依赖扩散 $\to$ Pimpl 惯用法
*   重复包含 $\to$ #pragma once 或 头文件保护宏



### 如果在头文件创建一个函数但在源文件中没有实现它会有bug吗？

头文件通常包含函数的声明，而源文件包含具体的实现。

>   编译阶段：
>
>   检查函数调用是否正确，是否有声明，如果有声明，编译器认为干函数在其他地方定义了，不会报错。
>
>   链接阶段：
>
>   把所有目标文件合并成一个可执行程序，如果在所有目标文件中都没有找到实现，此时链接器就会报错（未定义的引用）。

1.   函数没有使用
     编译和链接都没有问题
2.   函数使用了
     编译没问题，链接会报错
     如果该函数声明为 **inline**，编译期就会报错
     如果该函数是**模板函数**（需要在头文件声明和定义），编译器需要在编译期进行模板实例化（根据模板参数生成具体代码），编译期就会报错。



### 如何解决头文件循环包含的问题？

问题描述：`A.h` 和 `B.h` 互相包含，导致编译错误：

```cpp
// A.h
#include "B.h"
class A {
    B* b;
};

// B.h
#include "A.h"
class B {
    A* a;
};
```

解决方案：前置声明的方式：

当类/结构体仅被用作指针或引用时，无需包含完整定义，用前置声明替代头文件包含。在源文件（.cpp）中再包含具体头文件：

```cpp
// A.h
class B;  // 前置声明代替 #include "B.h"
class A {
    B* b;  // 仅需 B 的声明
};

// B.h
class A;  // 前置声明代替 #include "A.h"
class B {
    A* a;  // 仅需 A 的声明
};

// C.cpp
#include "A.h"
#include "B.h"
...
```



### 如何解决头文件依赖扩散的问题？

**什么是依赖扩散？**

所有包含 `A.h` 的文件都会间接包含 `B.h`

```cpp
// A.h
#ifndef A_H
#define A_H
#include "B.h"
class A {
private:
    B b;
};
#endif
```



**什么是 Pimpl（指向实现的指针）？**

将类的私有实现细节隐藏到源文件中，减少头文件依赖。

```cpp
// A.h
#ifndef A_H
#define A_H
class A {
private:
    struct Impl;  // 前置声明实现类
    Impl* impl;
};
#endif

// A.cpp
#include "A.h"
#include "B.h"
struct A::Impl{
    B b;  // 实现细节隐藏在源文件中
};
```



### 如何解决 C/CPP 中头文件重复包含的问题？

想要解决 C/CPP 中头文件重复包含的问题，有两种方式：

1.   在头文件的第一行使用预处理指令 **`#pragma once`**，`#pragma once` 是一个**非标准**的但广泛支持的预处理指令，它告诉编译器该头文件在单个编译过程中只应被包含一次。编译器在第一次遇到 `#pragma once` 时会记住该文件名，并在后续的包含操作中忽略它。

2.   使用预处理指令 **`#ifndef`**、**`#define`** 和 **`#endif`** 保护头文件：
     ```cpp
     #ifndef EXAMPLE_H
     #define EXAMPLE_H
     
     class MyClass {
     public:
         MyClass(); // 构造函数声明
         void myFunction(); // 成员函数声明
     };
     
     #endif
     ```



## 进程和线程

### 进城和线程的区别

```arduino
┌──────────────────────────┐ 高地址
│  内核空间 (仅内核访问)      │
├──────────────────────────┤
│  栈区 (Stack)             │ ← 每个线程独立分配
├──────────────────────────┤
│  堆区 (Heap)              │ ← 进程所有线程共享
├──────────────────────────┤
│  全局/静态区 (.data/.bss)  │ ← 进程共享
├──────────────────────────┤
│  代码段 (.text)           │ ← 进程共享，只读
└──────────────────────────┘ 低地址
```

**堆与线程的关系**

-   堆是进程级资源
    由进程向操作系统申请（如 `brk`/`mmap`），存放动态分配的内存（`malloc` / `new`）。
    所有线程都在同一个进程中运行，因此它们访问的是**同一块堆**。
-   线程共享堆的意义
    多个线程可以访问同一份动态分配的数据，实现数据共享。
    这也是为什么多线程访问堆上的数据时，需要**同步机制**（`mutex`、`spinlock` 等）来避免数据竞争。

**栈与线程的关系**

-   每个线程有**自己独立的栈空间**（stack），用来存放局部变量、函数调用信息等。
-   主线程的栈是在进程创建时分配的，子线程的栈由 `pthread_create` 等函数调用时分配（默认大小一般是 8MB，可修改）。

**结论**

*   同一进程中，不同线程共享堆**，共享全局区，独立栈。
*   堆上数据需要多线程同步，栈上数据天然线程安全（不共享）。



### 进程之间的通信方式有哪些？

**管道**：管道分为匿名管道和命名管道，管道本质上是一个内核中的一个缓存，当进程创建管道后会返回两个文件描述符，一个写入端一个输出端。缺点：半双工通信，一个管道只能一个进程写，一个进程读。不适合进程间频繁的交换数据

**消息队列**：可以边发边收，但是每个消息体都有最大长度限制，队列所包含的消息体的总数量也有上限并且在通信过程中存在用户态和内核态之间的数据拷贝问题

**共享内存**：解决了消息队列存在的内核态和用户态之间的数据拷贝问题。

**信号量**：本质上是一个计数器，当使用共享内存的通信方式时，如果有多个进程同时往共享内存中写入数据，有可能先写的进程的内容被其他进程覆盖了，信号量就用于实现进程间的互斥和同步PV操作不限于信号量+-1，而且可以任意加减正整数

**信号**：

**套接字**：



### 线程之间的通信方式有哪些？



### 多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？

因为在多进程中易发生多进程对资源进行竞争，如果一个进程集合里面的每一个进程都在等待这个集合中的其他一个进程才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁。产生死锁的四个条件：互斥条件、请求和保持条件、不可剥夺条件、环路等待条件。解决死锁的方法就是破坏上述任意一种条件。



### 串行、并行、并发、异步、同步

C++中 串行、并行、并发、同步、异步的区别

[任务执行模式全解析：并发、并行、串行与同步、异步的对比](https://blog.csdn.net/qq_42399932/article/details/144949891)

[深入浅出理解同步 /异步/并发/并行/串行](https://www.cnblogs.com/Archer-Fang/p/8962156.html)



## 智能指针

### 智能指针的本质是什么？它们的实现原理是什么？

智能指针本质是一个封装了一个原始C++指针的类模板，为了确保动态内存的安全性而产生的。实现原理是通过一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源。

其实现原理主要依赖于：

1.   **RAII 范式**：构造函数中获取资源，析构函数中释放资源，当智能指针对象离开作用域的时候，析构函数会自动释放它所持有的原始指针。
2.   **运算符重载**：重载 `*` 和 `->` 运算符，使其使用起来和普通指针一样。
3.   **引用计数** (`std::shared_ptr`场景)：
     *   通过一个**额外的计数器**记录当前有多少个 `shared_ptr` 指向同一块内存。
     *   当引用计数减为 0 时，自动释放资源。
4.   **移动语义**：`std::unique_ptr` 通过禁止拷贝构造和拷贝赋值，保证"唯一所有权"，但是其支持移动构造和移动赋值，转移所有权而不拷贝资源。



### `unique_ptr`



### `shared_ptr`



### `weak_ptr`



### 如何在一个派生类中定义一个父类的指针？



## C++ 关键字

### `const` v.s. `constexpr`



### `inline`

#### `inline` 的作用是什么

#### `inline` 是怎么加快函数运行效率





### `static`



### `volatile`





## 内存

### 内存对齐

#### 什么是内存对齐？



#### 为什么内存对齐？



### 内存布局

>   [计算机系统篇之链接（10）：.bss、.data 和 .rodata sections 之间的区别](https://csstormq.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AF%87%E4%B9%8B%E9%93%BE%E6%8E%A5%EF%BC%8810%EF%BC%89%EF%BC%9A.bss%E3%80%81.data%20%E5%92%8C%20.rodata%20section%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB)
>
>   [What is the difference between .rodata and .rdata](https://stackoverflow.com/questions/65745514/what-is-the-difference-between-rodata-and-rdata)





### 代码分析样例

分析如下代码的输出结果：

```cpp
#include <iostream>

class Base {
public:
    int a = 1;
    virtual void print(int n = 2) {
        std::cout << "Base: " << a + n << std::endl;
    }
};

class Derive : public Base {
public:
    int b = 3;
    virtual void print(int n = 10) override {
        std::cout << "Derive: " << b + n << std::endl;
    }
};

int main() {
    Base* arr = new Derive[10];
    arr[7].print();  // 输出结果是？
    delete[] arr;

    Base *ptr = new Derive();
    ptr->print();  // 输出结果是？
    delete ptr;

    return 0;
}
```

>   来源：[网易C++一面：代码分析题（多态+内存对齐）【码农Mark】](https://www.bilibili.com/video/BV1DoMwzhETG?spm_id_from=333.1245.0.0)

分析：

首先看代码第 24 行，可以发现使用了多态，**虚函数是动态绑定**的，但是**默认参数是静态绑定**的，所以 Base 类对象的 n = 2 Derive 类对象的 n = 10，所以第 25 行的输出为 5；

>   ```cpp
>   Derive *ptr = new Derive();
>   ptr->print();  // 默认参数来自 Derive::print(int n = 10), 输出结果是13
>   delete ptr;
>   ```
>
>   ```cpp
>   Base *ptr = new Derive();
>   ptr->print();  // 默认参数来自 Base::print(int n = 2), 输出结果是5
>   delete ptr;
>   ```
>
>   **虚函数的动态绑定只影响函数体的选择，不影响默认参数的选择**。默认参数在 **编译期** 按 **静态类型** 绑定。

然后看第 20 行，可以发现构造了一个 Derive 类数组，然后 arr 指向这个数组。第 21 行，想要使用 `arr[7]` 来调用 `Derive::print()` 函数，`arr[7]` 等价于 `*(arr + 7 * sizeof(Base))`，所以这里就要求 sizeof(Base) 和 sizeof(Derive) 相等。假设在 64 位机器上运行，从类的定义可以分别得到 `sizeof(Base) = 8B(虚函数指针) + 4B(整型变量 a) + 4B(填充用于内存对齐) = 16B`，`sizeof(Derive) = 8B(虚函数指针) + 4B(整型变量 a) + 4B(整型变量 b) = 16B`。可以看到这段代码中 sizeof(Base) 和 sizeof(Derive) 很巧合的相等了，那么 arr[7].print() 能够得到预期的结果 5。

所以最终的结果为：
```bash
Derive: 5
Derive: 5
```

:warning:但实际上这是一个很巧合的事情，如果 Derive 类多一个变量 int c，在运行时就会出现段错误。

:warning:**不能用父类指针指向子类对象数组**并用 `[]` 访问，否则是未定义行为。因为数组访问依赖 `sizeof(T)` 做偏移，而指针类型决定了偏移的单位。

解决方案：

1.   直接用**子类指针数组**：
     ```cpp
     Derive* arr = new Derive[10];
     arr[7].print(); // 安全
     delete[] arr;
     ```

2.   如果必须用 `Base*` 来管理多个 `Derive` 对象，使用**单个对象的指针容器**，比如 `std::vector<Base*>`：
     ```cpp
     std::vector<Base*> arr;
     for (int i = 0; i < 10; ++i) arr.push_back(new Derive());
     arr[7]->print();
     for (auto p : arr) delete p;
     ```

3.   用**智能指针**管理多态对象：
     ```cpp
     #include <memory>
     #include <vector>
     
     std::vector<std::unique_ptr<Base>> arr;
     for (int i = 0; i < 10; ++i)
         arr.push_back(std::make_unique<Derive>());
     arr[7]->print();
     ```




## C++ 多态

### 介绍多态，具体如何实现

C++ 中的多态分为静态多态和动态多态，没有特别指明的情况下，一般是指动态多态，即使用 virtual 实现的多态。

回答多态的实现原理，主要可以围绕在虚函数、虚函数表和虚函数表指针方向上。

多态通过虚函数实现。通过虚函数，子类可以重写父类的方法，当通过基类指针或引用调用时，会根据对象的实际类型调用对应的函数实现。

而这更深层次的原理，是通过虚表（vtable）和虚表指针（vptr）机制实现的。虚表是一个函数指针数组，包含了该类所有虚函数的地址，而虚表指针存储在对象实例中，指向属于该对象的虚表。



1）虚函数：在基类中使用 `virtual` 关键字声明虚函数之后，子类可以重写这个函数 (override)。

2）虚函数表 (vtable)：</br>
**生成时机**：每一个包含虚函数的<mark>类</mark>在**编译时**都会生成虚函数表 (vtable)，它存储该类所有虚函数的地址，对于每个类，编译器会创建唯一的 vtable。这个表是**类级别**的，和具体对象无关，所以在编译完成后就确定了。</br>
**存储位置**：`vtable` 存储在代码段 (`.rodata` 或常量区)。</br>
**生命周期**：程序加载到内存时建立，一直存在到程序结束 (不可修改)。

3）虚函数表指针 (vptr)：</br>
**生成时机**：每个包含虚函数的类的<mark>对象</mark>都会有一个隐藏成员 `vptr`，指向该类对应的虚函数表。这个 `vptr` 是在**构造函数执行时**由**编译器**自动插入代码进行初始化的，在基类构造阶段，`vptr` 会先指向基类的 `vtable`，在派生类构造阶段，`vptr` 会被更新为指向派生类的 `vtable`。在析构时，执行到基类析构函数时，`vptr` 会再次被更新为指向基类的 `vtable` (这也是为什么在基类析构函数中调用虚函数时会表现成"基类版本")。</br>
**存储位置**：对象内存中 (通常在对象的起始位置)。</br>
**生命周期**：随对象创建和销毁而存在 (栈上/堆上/全局区取决于对象分配方式)。

4）多态的调用机制：当通过基类指针或引用调用虚函数时，程序会通过该指针或引用找到对应的对象，然后通过 vptr 从 vtable 中找到对应的虚函数函数地址，最终调用适当的函数实现，这样程序能够在**运行时决定**调用哪一个函数实现。

5）实例：

```cpp
#include <iostream>
#include <vector>
#include <memory>

class Shape {
public:
    virtual ~Shape() = default;
    virtual void Draw() const = 0;
};

class Circle : public Shape {
public:
    virtual void Draw() const override {
        std::cout << "Draw a circle.\n";
    }
};

class Square : public Shape {
public:
    virtual void Draw() const override {
        std::cout << "Draw a square.\n";
    }
};

void RenderAll(const std::vector<std::unique_ptr<Shape>>& shapes) {
    for (const auto& shape : shapes) {
        shape->Draw();  // 动态绑定，调用具体实现
    }
}

int main() {
    std::vector<std::unique_ptr<Shape>> shapes;
    shapes.push_back(std::make_unique<Circle>());
    shapes.push_back(std::make_unique<Square>());
    RenderAll(shapes);

    return 0;
}
```

6）:warning:注意事项：

*   使用多态会有一定的内存和性能开销，因为每个类需要维护 vtable，每个对象也需要存储 vptr；
*   虚函数调用通常比普通函数调用更慢，因为多了一次指针间接寻址。



### 析构函数可以是虚函数吗，构造函数可以是虚函数吗

**构造函数不能是虚函数**。

虚函数的机制依赖于虚函数表，而虚表对象的建立需要在调用构造函数之后才能完成。因为构造函数是用来初始化对象的，而在对象的初始化阶段虚表对象还没有被建立，如果构造函数是虚函数，就会导致对象初始化和多态机制的矛盾，因此，构造函数不能是虚函数。

虽然构造函数不能是虚函数，但是**析构函数应当是虚函数**，特别是在基类中。这样做的目的是为了确保在删除一个指向派生类对象的基类指针时，能正确调用派生类对象的析构函数，从而避免资源泄露



### C++ 多态解决了什么问题

多态分为静态多态和动态多态

静态多态通过模板和函数重载实现

动态多态通过虚函数和继承实现

![image-20250806110659917](https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2024/202508061107767.png)

**静态多态**

```cpp
#include <iostream>
#include <string>

class Circle {
public:
    void Draw() const {
        std::cout << "Draw a circle.\n";
    }
};

class Square {
public:
    void Draw() const {
        std::cout << "Draw a square.\n";
    }
};

template <typename T>
void Draw(const T& shape) {
    shape.Draw();  // 编译时绑定
}

int main() {
    Circle c;
    Square s;

    Draw(c);  // 模板参数推导
    Draw(s);  // 模板参数推导

    return 0;
}
```

1.   复用：Draw 模板适用于任何有 Draw 方法的类型

2.   扩展：新增只需实现 Draw，无需修改模板

3.   解耦：Draw 不依赖基类，仅依赖隐式接口



**动态多态**

```cpp
#include <iostream>
#include <vector>

class Shape {
public:
    virtual ~Shape() = default;
    virtual void Draw() const = 0;
};

class Circle : public Shape {
public:
    virtual void Draw() const override {
        std::cout << "Draw a circle.\n";
    }
};

class Square : public Shape {
public:
    virtual void Draw() const override {
        std::cout << "Draw a square.\n";
    }
};

void RenderAll(const std::vector<Shape*>& shapes) {
    for (const auto* shape : shapes) {
        shape->Draw();  // 动态绑定，调用具体实现
    }
}

int main() {
    std::vector<Shape*> shapes = {new Circle(), new Square()};
    RenderAll(shapes);

    for (auto* shape : shapes) {
        delete shape;
    }

    return 0;
}
```

1.   复用：RenderAll
2.   扩展：新增只需继承 Shape 并实现 Draw()，无需修改 RenderAll
3.   解耦：RenderAll 只依赖抽象 Shape，不依赖具体图形类



[字节后端C++一面：C++多态解决了什么问题？【码农Mark】](https://www.bilibili.com/video/BV1vNTtzuEVj/?spm_id_from=333.1391.0.0&vd_source=f4cc25a44af6631d6f4db023b3bb88e4)



### 纯虚函数，虚函数表存储在哪



## 堆栈

### 堆和栈在操作系统的底层实现

扩展问题：

1.   为什么栈的分配速度比堆快？
2.   多线程程序中，栈和堆如何隔离？

![image-20250806150652747](https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2024/202508061509556.png)

[一步一图带你深入理解 Linux 虚拟内存管理 ](https://www.cnblogs.com/binlovetech/p/16824522.html)

栈在操作系统底层实现：

1.   线程创建的时候，操作系统为其创建栈空间；

2.   栈的使用：只需移动栈指针；

3.   硬件支持：寄存器 x86 下为 rsp 和 rbp；

4.   操作系统管理：

     a. 函数调用时，先将参数压栈；
     b. 执行 call 指令，将返回地址（返回上一级函数的下一条指令）压栈；
     c. 创建栈帧，保存旧的 rbp，设置新的 rbp；
     d. 可能为局部变量分配栈空间，以及清理局部变量等的栈空间；
     e. 恢复之前的 rbp 和 rsp，ret 指令弹出返回地址。



栈又分为进程栈和线程栈：
进程栈(主线程栈)：进程启动时创建；
线程栈：pthread_create clone 系统调用。



![image-20250806150912686](https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2024/202508061509668.png)

堆在用户态空间以及扩展方向(低地址向高地址扩展)。



1.   为什么栈的分配速度比堆快？
     答：因为栈只需要移动栈指针，而堆需要查找空闲块、处理碎片和系统调用。
2.   多线程程序中，栈和堆如何隔离？
     答：栈是线程私有的，堆是进程共享的，需要用同步机制控制，比如锁。



[拼多多C++二面：堆和栈在操作系统底层的实现、为什么栈的分配速度比堆快？](https://www.bilibili.com/video/BV1pZPieyEym/?spm_id_from=333.1391.0.0&vd_source=f4cc25a44af6631d6f4db023b3bb88e4)



## 设计模式

详见[常用的设计模式](../CPP/常用的设计模式.md)

### 单例模式

详见[单例模式](../CPP/常用的设计模式.md#_1)

### 工厂模式

详见[工厂模式](../CPP/常用的设计模式.md#_5)



## 参考资料

[1] [百度一面面经（C++）](https://blog.csdn.net/qq_29426201/article/details/147271710)

[2] [百度C++开发岗三面面经(已offer)](https://www.nowcoder.com/discuss/353155780922777600)

[3] [百度提前批，三面被推迟一周，喜提秋招第一凉](https://zhuanlan.zhihu.com/p/1935627993805463760)

[4] [百度c++开发面经（已OC）](https://www.nowcoder.com/feed/main/detail/1f237804872148f38fbcb8f6fae03ad9?sourceSSR=dynamic)

[5] [百度后端C++，一面、二面 + 主管面面经（已拿offer）](https://blog.csdn.net/weixin_55305220/article/details/121121416)

[6] [史上最全C/C++面试、C++面经八股文，一文带你彻底搞懂C/C++面试、C++面经！](https://blog.csdn.net/songbijian/article/details/132507421)

[7] [为什么你背八股像是在受刑，别人背就是享受](https://www.bilibili.com/video/BV12YVUzwEoB/?spm_id_from=333.1245.0.0&vd_source=f4cc25a44af6631d6f4db023b3bb88e4)

[8] [网易C++一面：代码分析题（多态+内存对齐）【码农Mark】](https://www.bilibili.com/video/BV1DoMwzhETG?spm_id_from=333.1245.0.0)

[9] [面试中计算机基础到底考什么，应该怎么学](https://www.bilibili.com/video/BV1oS9qYkEm9?spm_id_from=333.1245.0.0)

[10]

[11]

[12]

[13]

[14]
