# 数据结构与算法

## 面试常考

-   [ ] 链表
-   [ ] 栈
-   [ ] 队列
-   [ ] 哈希表
-   [ ] 树
-   [ ] 排序
-   [ ] 查找
-   [ ] 深度搜索
-   [ ] 广度搜索
-   [ ] 回溯
-   [ ] 动态规划
-   [ ] 



### 常见的排序算法有哪些？

| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 | 适用场景                     |
| ------------ | -------------- | -------------- | ---------- | ------ | ---------------------------- |
| **冒泡排序** | O(n²)          | O(n²)          | O(1)       | 稳定   | 教学用途，小规模数据         |
| **选择排序** | O(n²)          | O(n²)          | O(1)       | 不稳定 | 简单但低效                   |
| **插入排序** | O(n²)          | O(n²)          | O(1)       | 稳定   | 小规模或基本有序数据         |
| **希尔排序** | O(n log n)     | O(n²)          | O(1)       | 不稳定 | 改进的插入排序，中等规模数据 |
| **归并排序** | O(n log n)     | O(n log n)     | O(n)       | 稳定   | 大数据量，外部排序           |
| **快速排序** | O(n log n)     | O(n²)          | O(log n)   | 不稳定 | 通用最快，内存排序           |
| **堆排序**   | O(n log n)     | O(n log n)     | O(1)       | 不稳定 | 无需额外空间，优先级队列     |
| **计数排序** | O(n + k)       | O(n + k)       | O(k)       | 稳定   | 整数范围小且密集的数据       |
| **桶排序**   | O(n + k)       | O(n²)          | O(n + k)   | 稳定   | 均匀分布的数据               |
| **基数排序** | O(n × k)       | O(n × k)       | O(n + k)   | 稳定   | 多关键字排序（如字符串）     |



### 常见排序算法对比表

![image-20250901175435326](https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2025/202509011755556.png)

[十大经典排序算法](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)



## 数据结构





### 哈希表

---

哈希表，不同解决冲突的方法下，平均查找长度分别为？
{27, 23, 34, 14, 1, 55, 20, 19, 85, 83, 10, 68}，散列函数 $H(key) = key % 7$，采用链地址法来解决冲突，则在等概率情况下查找成功的平均查找长度为（）

---



#### 解决冲突的方法

1.   链地址法（Separate Chaining / 拉链法）
2.   开放定址法（Open Addressing）
     1.   **线性探测（Linear Probing）**
          -   探查序列：`h(k), h(k)+1, h(k)+2, ...` （取模表长 m）
          -   简单，但容易出现 **主聚集**（primary clustering）
     2.   **二次探测（Quadratic Probing）**
          -   探查序列：`h(k), h(k)+1^2, h(k)+2^2, ...`
          -   减轻主聚集，但可能出现 **二次聚集**
     3.   **双重哈希（Double Hashing）**
          -   使用第二个哈希函数生成步长：`h(k), h(k)+i*h2(k), ...`
          -   聚集问题最小，性能最好



### 树



![image-20250901181021932](https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2025/202509011810409.png)



#### Huffman 最优二叉树

---

有 A, B, C, D, E 五个字符，出现的频率分别为 2, 5, 3, 3, 4，由 A, B, C, D, E 生成的最优二叉树中，该树的带权路径长时多少？

1.   35
2.   49
3.   39
4.   45

---

这题考的是 **Huffman 最优二叉树（或最优前缀码）** 的构造与**带权路径长度（WPL）**的最小性。求法是用 Huffman 贪心：每步把当前频率表里最小的两个结点合并，合并代价累加，直到只剩一个结点；最终累加的合并权值之和就是最小带权路径长。

我们按步算一次（频率按升序考虑）：

初始频率：A=2，B=5，C=3，D=3，E=4。写成集合：{2,3,3,4,5}。

-   第1步：取最小的 2 和 3 合并 → 新节点权重 = 2 + 3 = 5。累加代价 = 5。当前集合：{3,4,5,5}。
-   第2步：取最小的 3 和 4 合并 → 新节点权重 = 3 + 4 = 7。累加代价 += 7。当前集合：{5,5,7}。
-   第3步：取最小的 5 和 5 合并 → 新节点权重 = 5 + 5 = 10。累加代价 += 10。当前集合：{7,10}。
-   第4步：取 7 和 10 合并 → 新节点权重 = 7 + 10 = 17。累加代价 += 17。集合只剩一个结点，停止。

把每步的代价加起来：5 + 7 + 10 + 17 = 39。

所以最优二叉树的**带权路径长 = 39**。答案选项为 **3. 39**。

---



#### 二叉树

*   二叉树
*   完全二叉树
*   满二叉树
*   二叉搜索树





**完全二叉树**和**满二叉树**的区别与联系。

结论：**所有的满二叉树都是完全二叉树，但并非所有的完全二叉树都是满二叉树。**
可以把满二叉树看作是完全二叉树的一种特例。

---

##### 1. 满二叉树

**定义：**
一棵深度为 `k` 的二叉树，如果其所有**非叶子节点**都有**两个子节点**，并且所有**叶子节点**都在**同一层**上，这样的二叉树称为满二叉树。

**通俗理解：** 每一层都“塞满了”节点，没有任何缺失。

**特点：**
*   **形状是完美的三角形**，非常严格和对称。
*   如果深度为 `k`，则总结点数为 `2^k - 1`（例如，深度3的满二叉树有 2³ - 1 = 7 个节点）。
*   第 `i` 层上的节点数固定为 `2^(i-1)`。

**示例（深度为3的满二叉树）：**
```
        A       // 第1层 (2⁰ = 1个节点)
       / \
      B   C     // 第2层 (2¹ = 2个节点)
     / \ / \
    D  E F  G   // 第3层 (2² = 4个节点)
```
*总节点数 = 1 + 2 + 4 = 7*

---

##### 2. 完全二叉树

**定义：**
一棵深度为 `k` 的二叉树，其所有节点都与深度为 `k` 的**满二叉树中编号从 1 到 n 的节点一一对应**。

这个定义比较抽象，我们可以用更通俗的方式理解：

1.  **除了最后一层**，其他所有层都是满的（即达到最大节点数）。
2.  **最后一层的所有叶子节点**都**尽可能地向左排列**。
3.  最后一个非叶子节点（即最后一个拥有子节点的节点）可能只有一个左子节点。

**通俗理解：** 按**从上到下、从左到右**的顺序构建和编号一棵二叉树，如果中间没有“跳过”任何编号，那么它就是完全二叉树。

**特点：**
*   **形状要求比满二叉树宽松**，但比普通二叉树严格。
*   高度为 `h` 的完全二叉树，节点数 `n` 的范围是：`2^(h-1) <= n < 2^h - 1`。
*   **非常适合用数组存储**。对于数组中位置 `i` 的节点（通常从下标1开始计算）：
    *   其父节点位置：`i / 2` (向下取整)
    *   其左子节点位置：`2 * i`
    *   其右子节点位置：`2 * i + 1`

**示例（都是深度为3的完全二叉树）：**

**示例1（最后一层未满，但向左靠齐）：**
```
        A
       / \
      B   C
     / \ 
    D   E
```
*这棵树按顺序编号为 A(1), B(2), C(3), D(4), E(5)。它与上面的满二叉树编号1到5的节点位置完全对应，没有跳过任何编号。*

**示例2（最后一层只有一个节点）：**

```
        A
       / \
      B   C
     /
    D
```
*编号同样连续：A(1), B(2), C(3), D(4)。*

**❌ 非完全二叉树的例子：**
```
        A
       / \
      B   C
       \ 
        E
```
*这棵树不是完全二叉树，因为在编号时，B节点（2）的左边应该先有左子节点（编号4），但它却“跳过”了4号位置，先有了一个右子节点（编号5），破坏了顺序性和连续性。*

---

##### 对比表格

| 特性       | 满二叉树                              | 完全二叉树                                                   |
| :--------- | :------------------------------------ | :----------------------------------------------------------- |
| **定义**   | 每一层都完全填满                      | 除最后一层外完全填满，且最后一层向左靠齐                     |
| **形状**   | 完美的三角形，绝对对称                | **可以看作是由一个满二叉树“从右至左”连续去掉若干个叶子节点形成的** |
| **节点数** | 深度为 `k` 时，节点数固定为 `2^k - 1` | 深度为 `k` 时，节点数不固定，范围是 `[2^(k-1), 2^k - 1]`     |
| **关系**   | **是**完全二叉树的一种特例            | **不一定是**满二叉树                                         |
| **存储**   | 可以用数组存储                        | **极其适合**用数组存储，是堆（Heap）结构的基础               |

##### 为什么这个概念很重要？

**完全二叉树**的概念是**堆**（Heap）这种数据结构的基础。堆就是一种完全二叉树，它保证了树结构的紧凑性，从而可以高效地使用数组进行存储和计算父节点/子节点的位置，使得插入和删除最值操作的时间复杂度可以保持在 `O(log n)`。



##### 二叉搜索树(BST)

-   必须满足**排序属性**：
    -   对于任意节点，其**左子树**的所有节点值都**小于**该节点，其**右子树**的所有节点值都**大于**该节点（假设无重复值）。
    -   中序遍历BST会得到一个升序序列。

-   用于快速查找、插入、删除（平均O(log⁡n)*O*(log*n*)），支持范围查询和有序遍历。
-   没有完全二叉树的要求，可能退化成链表（最坏情况时间复杂度O(n)*O*(*n*)），平衡BST（如AVL树、红黑树）通过旋转保持平衡。

```text
        30
       /  \
     20    50
    /     / 
   10    40
```



### 堆

堆通常是**完全二叉树**。





### 介绍红黑树

[【数据结构】史上最好理解的红黑树讲解，让你彻底搞懂红黑树](https://blog.csdn.net/cy973071263/article/details/122543826)





### 图

---

对一个有 n 个顶点 e 条边的图采用邻接表表示时，进行深度优先遍历的时间复杂度为（），空间复杂度为（）

1.   O(n), O(n + e)
2.   O(n + e),O(e)
3.   O(e), O(n)
4.   O(n + e), O(n + e)

---

这道题考察的是 **图的存储方式、DFS（深度优先遍历）的时间复杂度和空间复杂度**。我们逐步分析：

1️⃣ 图的存储方式：邻接表

-   邻接表存储每个顶点的边列表。

-   顶点数 = n，边数 = e（无向图每条边算两次邻接关系，或按有向图算一次）。

-   邻接表总空间开销：

    O(n+e)O(n + e)

    -   n: 保存每个顶点的头指针
    -   e: 保存所有边的链表节点

2️⃣ DFS 的时间复杂度

DFS 伪代码：

```
DFS(u):
    visited[u] = true
    for each v in adj[u]:
        if not visited[v]:
            DFS(v)
```

分析：

1.  **每个顶点**只会访问一次 → O(n)
2.  **每条边**只会检查一次（无向图通常会检查两次） → O(e)

所以 **时间复杂度 = O(n + e)**

3️⃣ DFS 的空间复杂度

DFS 递归栈/显式栈 + 访问标记数组：

1.  访问标记数组 `visited[n]` → O(n)
2.  递归栈深度最多 n → O(n)

**邻接表本身存储也需要 O(n+e) 空间**，但题问的是 DFS **运行时的额外空间**（通常是递归栈 + visited 数组），所以空间复杂度 = **O(n)**

4️⃣ 答案总结

-   **时间复杂度**：O(n + e)
-   **空间复杂度**：O(n)

✅ 正确选项：**4. O(n + e), O(n + e)**？

等等，注意选项里：

-   选项 4：O(n+e), O(n+e) ✅ 时间正确，但空间多算了边表
-   选项 1：O(n), O(n+e) ❌ 时间错
-   2：O(n+e), O(e) ❌ 空间错
-   3：O(e), O(n) ❌ 时间错

在笔试中，如果题目明确说 **“DFS 额外空间复杂度，不算存图空间”**，空间 = O(n)；
 如果把邻接表算进去存储，空间 = O(n+e)。

所以多数教材/笔试按选项设计，**选 4**，假设把存图空间也算进去。

---
