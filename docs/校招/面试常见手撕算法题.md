# 面试常见手撕算法题

## 链表

### 单链表

#### 定义

```cpp
struct ListNode {
    int value;
    ListNode* next;
    ListNode(int val) : value(val), next(nullptr) {}
};
```



#### 头插法

```cpp
#include <iostream>

struct ListNode {
    int value;
    ListNode* next;
    ListNode(int val) : value(val), next(nullptr) {}
};

int main() {
    int m = 10;
    ListNode* head = nullptr;
    // 使用头插法创建链表
    for (int i = 0; i < m; ++ i) {
        ListNode* node = new ListNode(i);
        node->next = head;
        head = node;
    }

    ListNode* current_node = head;
    while (current_node != nullptr) {
        std::cout << current_node->value << "->";
        current_node = current_node->next;
    }
    std::cout << "NULL" << std::endl;

    return 0;
}
```



#### 尾插法

```cpp
#include <iostream>

struct ListNode {
    int value;
    ListNode* next;
    ListNode(int val) : value(val), next(nullptr) {}
};

int main() {
    int m = 10;
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    // 使用尾插法创建链表
    for (int i = 0; i < m; ++ i) {
        ListNode* node = new ListNode(i);
        if (head == nullptr) {
            head = node;
            tail = node;
        } else {
            tail->next = node;
            tail = node;
        }
    }

    ListNode* current_node = head;
    while (current_node != nullptr) {
        std::cout << current_node->value << "->";
        current_node = current_node->next;
    }
    std::cout << "NULL" << std::endl;

    return 0;
}
```



#### 反转链表

[反转链表的三种方法--面试必考（图例超详细解析，小白一看就会！！！）](https://blog.csdn.net/weixin_45031801/article/details/139496847)

##### 题目描述

给你**单链表**的头节点 `head`，**请你反转链表，并返回反转后的链表。**



##### 头插法

创建一个新链表的头指针，每次将旧链表中的元素通过该头指针插入，从而实现链表反转。

```cpp
#include <iostream>

struct ListNode {
    int value;
    ListNode* next;
    ListNode() : value(0), next(nullptr) {}
    ListNode(int value_) : value(value_), next(nullptr) {}
    ListNode(int value_, ListNode* next_) : value(value_), next(next_) {}
};

ListNode* reverse(ListNode* head) {
    ListNode* new_head = nullptr;
    while (head) {
        ListNode* next = head->next;
        head->next = new_head;
        new_head = head;
        head = next;
    }
    return new_head;
}

int main() {

    int n = 10;
    ListNode* head = nullptr;
    for (int i = 0; i < n; ++ i) {
        ListNode* node = new ListNode(i);
        // 使用头插法创建链表
        node->next = head;
        head = node;
    }

    // 输出链表
    ListNode* curr_node = head;
    while (curr_node) {
        std::cout << curr_node->value << "->";
        curr_node = curr_node->next;
    }
    std::cout << "NULL" << std::endl;

    head = reverse(head);

    // 输出链表
    curr_node = head;
    while (curr_node) {
        std::cout << curr_node->value << "->";
        curr_node = curr_node->next;
    }
    std::cout << "NULL" << std::endl;

    return 0;
}
```



##### 迭代法

遍历旧链表，设计三个指针 `prev`、`curr`、`next`，其中 `prev` 指向 `curr` 的上一个节点，将 `curr` 指向的节点指向 `prev`，依次遍历，最终 `prev` 就是反转后链表的头结点指针。

```cpp
#include <iostream>

struct ListNode {
    int value;
    ListNode* next;
    ListNode() : value(0), next(nullptr) {}
    ListNode(int value_) : value(value_), next(nullptr) {}
    ListNode(int value_, ListNode* next_) : value(value_), next(next_) {}
};

ListNode* reverse(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;

    while (curr) {
        ListNode* next = curr->next;  // 保存下一个节点，避免丢失旧链表
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}

int main() {

    int n = 10;
    ListNode* head = nullptr;
    for (int i = 0; i < n; ++ i) {
        ListNode* node = new ListNode(i);
        // 使用头插法创建链表
        node->next = head;
        head = node;
    }

    // 输出链表
    ListNode* curr_node = head;
    while (curr_node) {
        std::cout << curr_node->value << "->";
        curr_node = curr_node->next;
    }
    std::cout << "NULL" << std::endl;

    head = reverse(head);

    // 输出链表
    curr_node = head;
    while (curr_node) {
        std::cout << curr_node->value << "->";
        curr_node = curr_node->next;
    }
    std::cout << "NULL" << std::endl;

    return 0;
}
```



##### 递归法

将上面的迭代方法改为递归方法，终止条件为 `curr == nullptr`。

```cpp
#include <iostream>

struct ListNode {
    int value;
    ListNode* next;
    ListNode() : value(0), next(nullptr) {}
    ListNode(int value_) : value(value_), next(nullptr) {}
    ListNode(int value_, ListNode* next_) : value(value_), next(next_) {}
};

ListNode* reverse(ListNode* curr, ListNode* prev) {
    if (curr == nullptr) return prev;

    ListNode* next = curr->next;  // 保存下一个节点，避免丢失旧链表
    curr->next = prev;

    return reverse(next, curr);
}

int main() {

    int n = 10;
    ListNode* head = nullptr;
    for (int i = 0; i < n; ++ i) {
        ListNode* node = new ListNode(i);
        // 使用头插法创建链表
        node->next = head;
        head = node;
    }

    // 输出链表
    ListNode* curr_node = head;
    while (curr_node) {
        std::cout << curr_node->value << "->";
        curr_node = curr_node->next;
    }
    std::cout << "NULL" << std::endl;

    head = reverse(head, nullptr);

    // 输出链表
    curr_node = head;
    while (curr_node) {
        std::cout << curr_node->value << "->";
        curr_node = curr_node->next;
    }
    std::cout << "NULL" << std::endl;

    return 0;
}
```



#### 删除链表的重复节点





## 动态规划

### 从一个序列中找到最长的严格单增子序列，输出最长的长度

$O(n^2)$

```cpp
#include <iostream>
#include <vector>

int main() {
    int n;
    std::cin >> n;
    std::vector<int> nums(n);
    for (int i = 0; i < n; ++ i) std::cin >> nums[i];
    std::vector<int> dp(n, 1);
    int ans = 1;
    for (int i = 0; i < n; ++ i) {
        for (int j = 0; j < i; ++ j) {
            if (nums[i] > nums[j]) {
                dp[i] = std::max(dp[j] + 1, dp[i]);
            }
        }
        ans = std::max(ans, dp[i]);
    }
    std::cout << ans << std::endl;
    
    return 0;
}
```





## 其他

### 2. 数组右移K位? 要求空间复杂度O(1),时间复杂度O(n)



### 3. 一个数组，求和为M的数据对，要求把所有结果返回



### 4. 判断一个字符串是否是IP地址?



### 5. 数组长度为N，数据是1-N,判断是否有重复数据? 要求时间复杂度O(n),空间复杂度O(1)

（剑指原题，但注意数据是1-N，数组下标是0-N-1,所以写的过程对应下标需要稍微转换）





### 数组中超过50%的元素

用摩尔投票法可以O（n）



### 二叉树中最近的公共祖先

第二道 二叉树中最近的公共祖先 我说了一下递归找两个节点是不一个在左一个在右，不在的话继续往那个方向搜
都是hot100的题，这个因为已经二刷过了很熟悉，基本上都秒答了



### 手撕 `std::vector`

详见：[自己动手实现vector容器](../Projects/自己动手实现vector容器.md)



## 参考资料

[1] [面试常见手撕算法](http://www.csview.cn/algorithm-mandatory/handtearing.html)

[2] 

[3] 

[4] 

[5]

[6]

[7]

[8]

[9]

[10]

