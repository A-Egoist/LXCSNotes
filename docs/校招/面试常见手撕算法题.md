# 面试常见手撕算法题

## 链表

### 单链表

#### 定义

```cpp
struct ListNode {
    int value;
    ListNode* next;
    ListNode(int val) : value(val), next(nullptr) {}
};
```



#### 头插法

```cpp
#include <iostream>

struct ListNode {
    int value;
    ListNode* next;
    ListNode(int val) : value(val), next(nullptr) {}
};

int main() {
    int m = 10;
    ListNode* head = nullptr;
    // 使用头插法创建链表
    for (int i = 0; i < m; ++ i) {
        ListNode* node = new ListNode(i);
        node->next = head;
        head = node;
    }

    ListNode* current_node = head;
    while (current_node != nullptr) {
        std::cout << current_node->value << "->";
        current_node = current_node->next;
    }
    std::cout << "NULL" << std::endl;

    return 0;
}
```



#### 尾插法

```cpp
#include <iostream>

struct ListNode {
    int value;
    ListNode* next;
    ListNode(int val) : value(val), next(nullptr) {}
};

int main() {
    int m = 10;
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    // 使用尾插法创建链表
    for (int i = 0; i < m; ++ i) {
        ListNode* node = new ListNode(i);
        if (head == nullptr) {
            head = node;
            tail = node;
        } else {
            tail->next = node;
            tail = node;
        }
    }

    ListNode* current_node = head;
    while (current_node != nullptr) {
        std::cout << current_node->value << "->";
        current_node = current_node->next;
    }
    std::cout << "NULL" << std::endl;

    return 0;
}
```



#### 反转链表

[反转链表的三种方法--面试必考（图例超详细解析，小白一看就会！！！）](https://blog.csdn.net/weixin_45031801/article/details/139496847)



#### 删除链表的重复节点





## 动态规划

### 从一个序列中找到最长的严格单增子序列，输出最长的长度

$O(n^2)$

```cpp
#include <iostream>
#include <vector>

int main() {
    int n;
    std::cin >> n;
    std::vector<int> nums(n);
    for (int i = 0; i < n; ++ i) std::cin >> nums[i];
    std::vector<int> dp(n, 1);
    int ans = 1;
    for (int i = 0; i < n; ++ i) {
        for (int j = 0; j < i; ++ j) {
            if (nums[i] > nums[j]) {
                dp[i] = std::max(dp[j] + 1, dp[i]);
            }
        }
        ans = std::max(ans, dp[i]);
    }
    std::cout << ans << std::endl;
    
    return 0;
}
```





## 其他

### 2. 数组右移K位? 要求空间复杂度O(1),时间复杂度O(n)



### 3. 一个数组，求和为M的数据对，要求把所有结果返回



### 4. 判断一个字符串是否是IP地址?



### 5. 数组长度为N，数据是1-N,判断是否有重复数据? 要求时间复杂度O(n),空间复杂度O(1)

（剑指原题，但注意数据是1-N，数组下标是0-N-1,所以写的过程对应下标需要稍微转换）





### 数组中超过50%的元素

用摩尔投票法可以O（n）



### 二叉树中最近的公共祖先

第二道 二叉树中最近的公共祖先 我说了一下递归找两个节点是不一个在左一个在右，不在的话继续往那个方向搜
都是hot100的题，这个因为已经二刷过了很熟悉，基本上都秒答了



### 手撕 `std::vector`

详见：[自己动手实现vector容器](../Projects/自己动手实现vector容器.md)



## 参考资料

[1] [面试常见手撕算法](http://www.csview.cn/algorithm-mandatory/handtearing.html)

[2] 

[3] 

[4] 

[5]

[6]

[7]

[8]

[9]

[10]

