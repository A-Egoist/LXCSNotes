# 星网锐捷

1.   25道选择题(50分)
2.   2道编程题(50分)

### 编程题1：(90% 测试点)

![QQ20250902-174328](https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2025/202509021842504.png)

错误原因，没有考虑到输入不存在字符 '0' 的情况。完整代码

```cpp
#include <iostream>
#include <string>
#include <vector>

const long long MOD = 1e9 + 7;

int main() {
    int n;
    std::cin >> n;
    std::string str;
    std::cin >> str;
    std::vector<int> arr;
    int last_zero = -1;
    for (int i = 0; i < str.size(); ++ i) {
        if (str[i] == '0' && last_zero == -1) {
            last_zero = i;
        } else if (str[i] == '0') {
            arr.push_back(i - last_zero);
            last_zero = i;
        }
    }
    if (last_zero == -1) {
        // 考虑输入没有字符 '0' 的情况。
        std::cout << 0;
        return 0;
    }
    
    long long res = 1;
    for (auto& num : arr) {
        res = res * num % MOD;
    }
    printf("%lld", res);

    return 0;
}
```





### 编程题2：(40% 测试点)

![QQ20250902-174339](https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2025/202509021842863.png)

错误原因，思路是对的，要想吃的总量最多，应该从最右边非零的位置吃，但是使用了贪心实现，可能中间存在一些bug，导致测试点没过。用动态规划更简单实现：

```cpp
#include <iostream>
#include <climits>
#include <queue>
const int N = 1000050;

int main() {
    int n;
    std::cin >> n;
    int s[N] = {0};
    for (int i = 1; i <= n; ++ i) {
        std::cin >> s[i];
    }

    int dp[N] = {0};  // dp[i] 表示第 i 个盘子中，小强最多能吃多少个烧饼
    // 由题目分析可知，dp[i] 的值等于其左侧最小值的 s[i]

    dp[1] = s[1];
    for (int i = 2; i <= n; ++ i) {
        dp[i] = std::min(dp[i - 1], s[i]);
    }

    long long res = 0;
    for (int i = 1; i <= n; ++ i) {
        res += dp[i];
    }

    std::cout << res << std::endl;

    return 0;
}
```

更进一步，就是维护左侧最小烧饼数量

```cpp
#include <iostream>
#include <climits>
#include <queue>
const int N = 1000050;

int main() {
    int n;
    std::cin >> n;
    int s[N] = {0};
    for (int i = 1; i <= n; ++ i) {
        std::cin >> s[i];
    }

    int pre_min = INT_MAX;
    long long res = 0;
    for (int i = 1; i <= n; ++ i) {
        res += std::min(pre_min, s[i]);
        pre_min = std::min(pre_min, s[i]);
    }

    std::cout << res << std::endl;

    return 0;
}
```

