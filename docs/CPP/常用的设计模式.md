# 常用的设计模式

设计模式可以分为：

1.   创建型模式：单例模式、简单工厂模式、抽象工厂模式、生成器/建造者模式、原型模式
2.   结构型模式：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式
3.   行为模式：责任链模式、命令模式、迭代器模式、中介者模式、备忘录模式、观察者模式、策略模式、状态模式、模板方法模式、访问者模式



## 单例模式

单例模式（Singleton Pattern）保证**某个类在全局只有一个实例**，并提供一个全局访问点。
 常见应用场景：

-   全局配置管理（Config）
-   日志系统（Logger）
-   线程池（ThreadPool）
-   数据库连接池（ConnectionPool）



饿汉模式和懒汉模式

### 饿汉模式



### 懒汉模式



## 工厂模式

>   参考资料：[影石C++一面：详细介绍工厂模式（简单工厂、工厂方法、抽象工厂）【码农Mark】](https://www.bilibili.com/video/BV1kXgPzfE45?spm_id_from=333.1245.0.0)

工厂模式的核心思想是将对象创建的复杂性隐藏在工厂内部，而不是暴露在代码调用处。

工厂模式有三种模式：

1.   简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类的实例；
2.   工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类；
3.   抽象工厂：定义一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

案例：游戏角色创建

想象一个 RPG 游戏，需要创建不同类型的角色：

战士（Warrior）：高血量、高攻击力、低魔力

法师（Mage）：低血量、低攻击力、高魔力

弓箭手（Archer）：中等血量、中等攻击力、中等魔力

随着游戏发展，还会添加更多角色类型，每个角色都有不同的属性和技能。



### 基本类

```cpp
class Character {
protected:
    std::string name;
    int health;
    int attack;
    int magic;
public:
    Character(const std::string& n, int h, int a, int m) : name(n), health(h), attack(a), magic(m) {}
    virtual ~Character() = default;
    virtual void showInfo() const {
        std::cout << "角色：" << name << std::endl;
        std::cout << "血量：" << health << std::endl;
        std::cout << "攻击力：" << attack << std::endl;
        std::cout << "魔力：" << magic << std::endl;
    }

    virtual void specialSkill() = 0;

    std::string getName() const {
        return name;
    }
};

// 具体角色类 - 战士
class Warrior : public Character {
public:
    Warrior(const std::string& name) : Character(n: name, h: 150, a: 80, m:20) {}
    void specialSkill() override {
        std::cout << name << "使用【狂暴攻击】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 战士 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：近战攻击，高血量" << std::endl;
    }
};

// 具体角色类 - 法师
class Mage : public Character {
public:
    Mage(const std::string& name) : Character(n: name, h: 80, a: 30, m:120) {}

    void specialSkill() override {
        std::cout << name << "释放【火球术】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 法师 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：魔法攻击，高魔力" << std::endl;
    }
};

// 具体角色类 - 弓箭手
class Archer : public Character {
public:
    Archer(const std::string& name) : Character(n: name, h: 100, a: 70, m: 50) {}
    
    void specialSkill() override {
        std::cout << name << "使用【穿透射击】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 弓箭手 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：远程攻击，平衡属性" << std::endl;
    }
};
```



### 简单工厂模式

由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类的实例。

```cpp
#include <iostream>
#include <memory>
#include <string>

// 抽象角色类
class Character {
protected:
    std::string name;
    int health;
    int attack;
    int magic;
public:
    Character(const std::string& n, int h, int a, int m) : name(n), health(h), attack(a), magic(m) {}
    virtual ~Character() = default;
    virtual void showInfo() const {
        std::cout << "角色：" << name << std::endl;
        std::cout << "血量：" << health << std::endl;
        std::cout << "攻击力：" << attack << std::endl;
        std::cout << "魔力：" << magic << std::endl;
    }

    virtual void specialSkill() = 0;

    std::string getName() const {
        return name;
    }
};

// 具体角色类 - 战士
class Warrior : public Character {
public:
    Warrior(const std::string& name) : Character(name, 150, 80, 20) {}
    void specialSkill() override {
        std::cout << name << "使用【狂暴攻击】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 战士 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：近战攻击，高血量" << std::endl;
    }
};

// 具体角色类 - 法师
class Mage : public Character {
public:
    Mage(const std::string& name) : Character(name, 80, 30, 120) {}

    void specialSkill() override {
        std::cout << name << "释放【火球术】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 法师 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：魔法攻击，高魔力" << std::endl;
    }
};

// 具体角色类 - 弓箭手
class Archer : public Character {
public:
    Archer(const std::string& name) : Character(name, 100, 70, 50) {}
    
    void specialSkill() override {
        std::cout << name << "使用【穿透射击】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 弓箭手 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：远程攻击，平衡属性" << std::endl;
    }
};

// 简单工厂
enum class CharacterType {
    WARRIOR,
    MAGE,
    ARCHER
};

class SimpleCharacterFactory {
public:
    static std::unique_ptr<Character> CreateCharacter(CharacterType type, const std::string& name) {
        switch (type)
        {
        case CharacterType::WARRIOR:
            return std::make_unique<Warrior>(name);
            break;
        case CharacterType::MAGE:
            return std::make_unique<Mage>(name);
            break;
        case CharacterType::ARCHER:
            return std::make_unique<Archer>(name);
            break;
        default:
            break;
        }
    }
};

int main() {
    std::unique_ptr<SimpleCharacterFactory> factory = std::make_unique<SimpleCharacterFactory>();

    auto warrior = SimpleCharacterFactory::CreateCharacter(CharacterType::WARRIOR, "莱戈拉斯");
    auto mage = SimpleCharacterFactory::CreateCharacter(CharacterType::MAGE, "加拉德丽尔");
    auto archer = SimpleCharacterFactory::CreateCharacter(CharacterType::ARCHER, "图兰迪尔");

    warrior->showInfo();
    warrior->specialSkill();

    mage->showInfo();
    mage->specialSkill();

    archer->showInfo();
    archer->specialSkill();

    return 0;
}
```



### 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。

```cpp
#include <iostream>
#include <memory>
#include <string>

// 抽象角色类
class Character {
protected:
    std::string name;
    int health;
    int attack;
    int magic;
public:
    Character(const std::string& n, int h, int a, int m) : name(n), health(h), attack(a), magic(m) {}
    virtual ~Character() = default;
    virtual void showInfo() const {
        std::cout << "角色：" << name << std::endl;
        std::cout << "血量：" << health << std::endl;
        std::cout << "攻击力：" << attack << std::endl;
        std::cout << "魔力：" << magic << std::endl;
    }

    virtual void specialSkill() = 0;

    std::string getName() const {
        return name;
    }
};

// 具体角色类 - 战士
class Warrior : public Character {
public:
    Warrior(const std::string& name) : Character(name, 150, 80, 20) {}
    void specialSkill() override {
        std::cout << name << "使用【狂暴攻击】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 战士 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：近战攻击，高血量" << std::endl;
    }
};

// 具体角色类 - 法师
class Mage : public Character {
public:
    Mage(const std::string& name) : Character(name, 80, 30, 120) {}

    void specialSkill() override {
        std::cout << name << "释放【火球术】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 法师 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：魔法攻击，高魔力" << std::endl;
    }
};

// 具体角色类 - 弓箭手
class Archer : public Character {
public:
    Archer(const std::string& name) : Character(name, 100, 70, 50) {}
    
    void specialSkill() override {
        std::cout << name << "使用【穿透射击】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 弓箭手 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：远程攻击，平衡属性" << std::endl;
    }
};

// 工厂方法
class CharacterFactory {
public:
    virtual ~CharacterFactory() = default;
    virtual std::unique_ptr<Character> createCharacter(const std::string& name) = 0;

    std::unique_ptr<Character> createCharacterWithSetip(const std::string& name) {
        // 规范角色的创建流程：角色生成 -> 初始化
        auto character = createCharacter(name);
        setupCharacter(character.get());
        return character;
    }
protected:
    virtual void setupCharacter(Character* character) {
        std::cout << "角色 " << character->getName() << " 创建完成，进行基础设置..." << std::endl;
    }
};

class WarriorFactory : public CharacterFactory {
public:
    virtual std::unique_ptr<Character> createCharacter(const std::string& name) override {
        return std::make_unique<Warrior>(name);
    }
protected:
    virtual void setupCharacter(Character* character) {
        CharacterFactory::setupCharacter(character);
        std::cout << "为战士配备铁剑和盾牌..." << std::endl;
    }
};

class MageFactory : public CharacterFactory {
public:
    virtual std::unique_ptr<Character> createCharacter(const std::string& name) override {
        return std::make_unique<Mage>(name);
    }
protected:
    virtual void setupCharacter(Character* character) {
        CharacterFactory::setupCharacter(character);
        std::cout << "为法师配备法杖和法袍..." << std::endl;
    }
};

class ArcherFactory : public CharacterFactory {
public:
    virtual std::unique_ptr<Character> createCharacter(const std::string& name) override {
        return std::make_unique<Archer>(name);
    }
protected:
    virtual void setupCharacter(Character* character) {
        CharacterFactory::setupCharacter(character);
        std::cout << "为弓箭手配备弓和箭筒..." << std::endl;
    }
};

int main() {
    std::unique_ptr<CharacterFactory> warrior_factory = std::make_unique<WarriorFactory>();
    std::unique_ptr<CharacterFactory> mage_factory = std::make_unique<MageFactory>();
    std::unique_ptr<CharacterFactory> archer_factory = std::make_unique<ArcherFactory>();

    auto warrior = warrior_factory->createCharacterWithSetip("莱戈拉斯");
    auto mage = mage_factory->createCharacterWithSetip("加拉德丽尔");
    auto archer = archer_factory->createCharacterWithSetip("图兰迪尔");

    warrior->showInfo();
    warrior->specialSkill();

    mage->showInfo();
    mage->specialSkill();

    archer->showInfo();
    archer->specialSkill();

    return 0;
}
```



### 抽象工厂模式

定义一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

设计思路

*   抽象产品（Abstract Product）：`Character` （角色基类）
*   具体产品（Concrete Product）：
    *   战士（`Warrior`）
    *   法师（`Mage`）
    *   弓箭手（`Archer`）
*   抽象工厂（Abstract Factory）：`RaceFactory`（种族工厂接口）
*   具体工厂（Concrete Factory）：
    *   人族工厂（`HumanFactory`）
    *   精灵族工厂（`ElfFactory`）
    *   矮人族工厂（`DwarfFactory`）

```cpp
#include <iostream>
#include <memory>
#include <string>

// 抽象角色类
class Character {
protected:
    std::string name;
    int health;
    int attack;
    int magic;
public:
    Character(const std::string& n, int h, int a, int m) : name(n), health(h), attack(a), magic(m) {}
    virtual ~Character() = default;
    virtual void showInfo() const {
        std::cout << "角色：" << name << std::endl;
        std::cout << "血量：" << health << std::endl;
        std::cout << "攻击力：" << attack << std::endl;
        std::cout << "魔力：" << magic << std::endl;
    }

    virtual void specialSkill() = 0;

    std::string getName() const {
        return name;
    }
};

// 具体角色类 - 战士
class Warrior : public Character {
public:
    Warrior(const std::string& name, int h, int a, int m) : Character(name, h, a, m) {}
    void specialSkill() override {
        std::cout << name << "使用【狂暴攻击】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 战士 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：近战攻击，高血量" << std::endl;
    }
};

// 具体角色类 - 法师
class Mage : public Character {
public:
    Mage(const std::string& name, int h, int a, int m) : Character(name, h, a, m) {}

    void specialSkill() override {
        std::cout << name << "释放【火球术】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 法师 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：魔法攻击，高魔力" << std::endl;
    }
};

// 具体角色类 - 弓箭手
class Archer : public Character {
public:
    Archer(const std::string& name, int h, int a, int m) : Character(name, h, a, m) {}
    
    void specialSkill() override {
        std::cout << name << "使用【穿透射击】！" << std::endl;
    }

    void showInfo() const override {
        std::cout << "=== 弓箭手 ===" << std::endl;
        Character::showInfo();
        std::cout << "特长：远程攻击，平衡属性" << std::endl;
    }
};

// 抽象工厂 - 种族工厂
class RaceFactory {
public:
    virtual ~RaceFactory() = default;
    virtual std::unique_ptr<Character> createWarrior(const std::string& name) = 0;
    virtual std::unique_ptr<Character> createMage(const std::string& name) = 0;
    virtual std::unique_ptr<Character> createArcher(const std::string& name) = 0;
};

// 具体工厂 - 人族
class HumanFactory : public RaceFactory {
public:
    std::unique_ptr<Character> createWarrior(const std::string& name) override {
        return std::make_unique<Warrior>(name, 150, 80, 20);
    }
    std::unique_ptr<Character> createMage(const std::string& name) override {
        return std::make_unique<Warrior>(name, 90, 35, 110);
    }
    std::unique_ptr<Character> createArcher(const std::string& name) override {
        return std::make_unique<Warrior>(name, 110, 75, 40);
    }
};

// 具体工厂 - 精灵族
class ElfFactory : public RaceFactory {
public:
    std::unique_ptr<Character> createWarrior(const std::string& name) override {
        return std::make_unique<Warrior>(name, 120, 85, 40);
    }
    std::unique_ptr<Character> createMage(const std::string& name) override {
        return std::make_unique<Warrior>(name, 80, 30, 130);
    }
    std::unique_ptr<Character> createArcher(const std::string& name) override {
        return std::make_unique<Warrior>(name, 100, 90, 60);
    }
};

// 具体工厂 - 矮人族
class DwarfFactory : public RaceFactory {
public:
    std::unique_ptr<Character> createWarrior(const std::string& name) override {
        return std::make_unique<Warrior>(name, 180, 85, 15);
    }
    std::unique_ptr<Character> createMage(const std::string& name) override {
        return std::make_unique<Warrior>(name, 100, 40, 100);
    }
    std::unique_ptr<Character> createArcher(const std::string& name) override {
        return std::make_unique<Warrior>(name, 120, 70, 35);
    }
};

int main() {
    std::unique_ptr<RaceFactory> human_facory = std::make_unique<HumanFactory>();
    std::unique_ptr<RaceFactory> elf_facory = std::make_unique<ElfFactory>();
    std::unique_ptr<RaceFactory> dwarf_facory = std::make_unique<DwarfFactory>();

    auto warrior = human_facory->createWarrior("莱戈拉斯");
    auto mage = elf_facory->createMage("加拉德丽尔");
    auto archer = dwarf_facory->createArcher("图兰迪尔");

    warrior->showInfo();
    warrior->specialSkill();

    mage->showInfo();
    mage->specialSkill();

    archer->showInfo();
    archer->specialSkill();

    return 0;
}
```



### 总结

1.   简单工厂 - 集中式创建：
     优点：实现简单，使用方便
     缺点：违反开闭原则，扩展需要修改工厂类
2.   工厂方法 - 多态创建：
     优点：符合开闭原则，易于扩展
     缺点：需要创建多个工厂类
3.   抽象工厂 - 产品族创建：
     优点：可以创建相关产品族，保证产品兼容性
     缺点：扩展产品族较困难



## 状态模式



## 原型模式



## 观察者模式



## 发布-订阅模式



## 访问者模式





## 参考资料

【1】[设计模式](https://subingwen.cn/design-patterns/)

【2】



