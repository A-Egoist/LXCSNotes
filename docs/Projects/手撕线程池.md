# 手撕线程池

## 核心思想

线程池：维持管理一定数量线程的池式结构。线程池的核心思想是**复用线程**。它预先创建好一组线程，并将任务提交到一个任务队列中。当有空闲线程时，它会从任务列表中取出任务并执行。这样可以避免频繁地创建和销毁线程所带来的性能开销。

为什么需要线程池？避免占用当前线程池，在线程池异步执行耗时任务。

耗时任务分为：

*   CPU 密集型
*   I/O 密集型

线程池的工作流程：

生产者线程将任务放到任务队列中，消费者线程从任务队列中取出任务去执行。

![image-20250831102549702](https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2025/202508311109747.png)

参考 workflow

![image-20250831105509220](https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2025/202508311120771.png)

## 实现过程

### 线程池的组件

一个基本的线程池需要包含以下几个核心组件：

1.   任务队列：用于存放待执行的任务。任务可以是 `std::function` 对象，这样可以支持各种可调用对象，如函数、lambda 表达式、成员函数等。
2.   线程池中的线程：这些线程会不断地从任务队列中取出任务并执行。
3.   同步机制：
     *   互斥锁(`std::mutex`)：保证任务队列在多线程访问时的线程安全。
     *   条件变量(`std::condition_variable`)：用于线程间的通信，即当任务队列为空时，工作线程等待；当有新任务到来时，主线程可以唤醒一个或多个等待中的工作线程。
4.   线程池的控制：需要一个 `shutdown` 或 `stop` 机制来优雅地关闭线程池，并确保所有任务都被执行或被清理。

接下来，我们将任务队列和线程池的功能分离，通过封装一个**阻塞队列(BlockingQueue)**来处理任务的同步和并发问题，使得线程池的逻辑更加清晰和简洁。

### 阻塞队列

使用**生产者-消费者模型**的特性，生产者将任务 push 到队列中，消费者从队列中 pop 出任务。

为了避免工作线程被虚假唤醒，使用谓词(predicate)。

```cpp
template <typename T>
class BlockingQueue {
private:
    bool nonblock_;  // 控制队列是否在没有任务时阻塞，当为 true 时，pop 操作将不再等待，而是立即返回。这用于线程池的优雅退出。
    std::queue<T> queue_;  // 存储 task
    std::mutex mutex_;  // 互斥锁，保护 queue_ 在多线程访问时的线程安全
    std::condition_variable not_empty_;  // 条件变量，用于线程间通信
    
public:
    BlockingQueue(bool nonblock = false) : nonblock_(nonblock) {}

    // 入队操作
    void push(const T& value) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(value);
        not_empty_.notify_one();  // 唤醒一个可能正在等待任务的工作线程
    }

    // 出队操作
    bool pop(T& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        // 使用谓词(predicate)避免虚假唤醒
        not_empty_.wait(lock, [this] { return !queue_.empty() || nonblock_; });
        // 判断是否是因为 nonblock_ = true 的条件唤醒
        if (queue_.empty()) return false;
		
        // 因为任务队列非空而被唤醒，工作线程获取任务
        value = queue_.front();
        queue_.pop();
        return true;
    }

    // 解除阻塞在当前队列的线程
    void Cancle() {
        std::lock_guard<std::mutex> lock(mutex_);
        nonblock_ = true;
        not_empty_.notify_all();
    }
};
```

单个任务队列中，当生产者 push 和消费者 pop 的时候都会发生碰撞，因为他们共用一把锁。参考 workflow 的设计，我们用两个队列来实现，一个是生产者队列，一个是消费者队列。当消费者队列为空时，我们将生产者队列和消费者队列交换，只有在这个时候生产者线程和消费者线程才会发生碰撞。(双缓冲区设计)

```cpp
template <typename T>
class BlockingQueuePro {
private:
    bool nonblock_;
    std::queue<T> producer_queue_;
    std::queue<T> consumer_queue_;
    std::mutex producer_mutex_;
    std::mutex consumer_mutex_;
    std::condition_variable not_empty_;

    int SwapQueue_() {
        std::unique_lock<std::mutex> lock(producer_mutex_);
        // 触发交换时，消费者队列为空，若此时生产者队列也为空，则会触发阻塞。
        not_empty_.wait(lock, [this] { return !producer_queue_.empty() || nonblock_; });
        std::swap(producer_queue_, consumer_queue_);
        return consumer_queue_.size();
    }

public:
    BlockingQueuePro(bool nonblock = false) : nonblock_(nonblock) {}

    // 入队操作
    void push(const T& value) {
        std::lock_guard<std::mutex> lock(producer_mutex_);
        producer_queue_.push(value);
        not_empty_.notify_one();
    }

    // 出队操作
    bool pop(T& value) {
        std::unique_lock<std::mutex> lock(consumer_mutex_);
        // 如果消费者队列为空，且在交换之后消费者队列也为空，说明触发此次交换的原因是 nonblock_ 为 true，则工作线程应该优雅地退出了。
        if (consumer_queue_.empty() && SwapQueue_() == 0) return false;
        // 如果交换之后的消费者队列不为空，这说明工作线程可以正常的消费。
        value = consumer_queue_.front();
        consumer_queue_.pop();
        return true;
    }

    // 解除阻塞在当前队列的线程
    void Cancle() {
        std::lock_guard<std::mutex> lock(producer_mutex_);
        nonblock_ = true;
        not_empty_.notify_all();
    }
};
```





### 线程池

两个关键的成员变量：任务队列(`task_queue_`)和工作线程数组(`workers_`)。

`Worker()` 函数是工作线程执行的函数，用于从任务队列中获取任务并执行，`task_queue_.pop(task)` 的返回为 `false`，即 `task_queue_.Cancle()` 被调用时，所有的工作线程都会优雅地退出。

构造函数会创建指定数量的工作线程，每个工作线程都会调用当前对象的 `Worker()` 函数，因为使用了 `[this]` 捕获。

析构函数会在 `ThreadPool` 对象生命周期结束时触发，首先会通过调用 `task_queue_.Cancle()` 来通知所有的工作线程优雅地退出，并等待所有工作线程结束，从而使得线程池能够优雅地退出。

可变参数模板函数 `Post()`，用于将一个可调用对象(函数、lambda 表达式、函数对象)和其参数打包成一个新的、无参数的函数对象，并将这个打包好的函数对象放入任务队列(`task_queue_`)中。这其中用到了**可变参数模板**、**万能引用**、**完美转发**、**参数绑定(`std::bind`)**：

1. 可变参数模板（`typename... Args`）

-   **`template <typename F, typename... Args>`**：
    -   `typename F`：表示 `Post` 函数可以接受任何类型的**可调用对象**，比如函数指针、函数对象（functor）或lambda表达式。
    -   `typename... Args`：这里的 `...` 是 C++11 引入的语法，表示一个**参数包**。它允许 `Post` 函数接受任意数量、任意类型的参数。例如，`Post(my_func, 10, "hello", 3.14)` 就会将 `Args` 识别为 `int`, `const char*`, `double`。

2. 完美转发（`F&& f, Args&&... args`）

-   **`F&& f, Args&&... args`**：
    -   这是**万能引用（Universal Reference）**，它既可以绑定左值（lvalue），也可以绑定右值（rvalue）。
-   **`std::forward<F>(f)` 和 `std::forward<Args>(args)...`**：
    -   **这是完美转发的核心。** `std::forward` 能够根据 `f` 和 `args` 的原始类型，将其**以原始的值类别（左值或右值）**转发给 `std::bind`。
    -   **重要性**：如果没有完美转发，所有参数都会被复制（即使它们是右值），这对于处理大型对象（如 `std::vector`）来说效率低下。有了完美转发，如果传递的是一个临时对象（右值），它就会被高效地**移动（move）** 而不是复制，从而提升性能。

3. 参数绑定（`std::bind`）

-   **`auto task = std::bind(std::forward<F>(f), std::forward<Args>(args)...);`**：
    -   **`std::bind`** 是一个函数适配器，它接收一个可调用对象和一系列参数，并返回一个新的**函数对象**。这个新的函数对象**绑定**了原始函数和参数，当你调用它时，它会使用绑定的参数调用原始函数。
    -   比如，当你调用 `pool.Post(add, 5, 3);` 时，`std::bind` 会创建一个新的函数对象 `task`。当工作线程执行 `task()` 时，`task` 内部会调用 `add(5, 3)`。
    -   **`std::function`**： `std::bind` 返回的函数对象可以被赋值给 `std::function<void()>`，因为 `std::function` 可以存储任何可调用对象。这里的 `void()` 表示这个函数对象不接受任何参数，也不返回任何值，这正是工作线程所期望的任务类型。

```cpp
class ThreadPool {
private:
    BlockingQueue<std::function<void()>> task_queue_;  // 任务队列
    // BlockingQueuePro<std::function<void()>> task_queue_;  // 任务队列
    std::vector<std::thread> workers_;  // 工作线程

    void Worker() {
        while (true) {
            std::function<void()> task;
            if (!task_queue_.pop(task)) break;
            task();
        }
    }

public:
    // 构造函数
    explicit ThreadPool(int num_threads) {
        for (std::size_t i = 0; i < num_threads; ++ i) {
            workers_.emplace_back([this]{ Worker(); });
        }
    }

    // 析构函数
    ~ThreadPool() {
        task_queue_.Cancle();
        for (auto& worker: workers_) {
            if (worker.joinable()) worker.join();
        }
    }

    // 发布任务到线程池
    // F 表示一个可调用对象(函数、lambda 表达式、函数对象等)，Args 表示函数对象的参数类型
    // Args... 是一个可变参数模板，表示可以接收任意数量的参数
    template <typename F, typename... Args>
    void Post(F&& f, Args&&... args) {
        auto task = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        task_queue_.push(task);
    }
};
```





### 测试代码

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>
#include <chrono>
#include "ThreadPool.h"

// 全局计数器，用于统计任务完成的数量
std::atomic<int> task_counter(0);

void Task(int id) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));  // 休眠 100 毫秒，模拟任务执行时间
    std::cout << "Task " << id << " executed by thread " << std::this_thread::get_id() << std::endl;
    ++ task_counter;  // 任务完成，计数器加 1
}

// 生产者线程函数
void Producer(ThreadPool& pool, int producer_id, int num_tasks) {
    for (int i = 0; i < num_tasks; ++ i) {
        int task_id = producer_id * 1000 + i;  // 生成唯一的任务 id
        pool.Post(Task, task_id);  // 提交任务到线程池
        std::cout << "Producer " << producer_id << " posted task " << task_id << std::endl;
    }
}

int main() {
    const int num_producers = 4;  // 生产者线程数量
    const int num_tasks_per_producer = 10;  // 每个生产者提交的任务数量
    const int num_threads_in_pool = 2;  // 线程池中的工作线程数量

    ThreadPool pool(num_threads_in_pool);  // 创建线程池
    std::vector<std::thread> producers;  // 生产者线程集合

    // 启动生产者线程
    for (int i = 0; i < num_producers; ++ i) {
        producers.emplace_back(Producer, std::ref(pool), i, num_tasks_per_producer);
    }

    // 等待所有生产者线程完成
    for (auto& producer : producers) {
        producer.join();
    }

    // 等待所有任务完成
    while (task_counter < num_producers * num_tasks_per_producer) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    std::cout << "All tasks completed. Total tasks executed: " << task_counter << std::endl;

    return 0;
}
```



## 完整代码

`ThreadPool.h`

```cpp
#include <queue>
#include <thread>
#include <vector>
#include <functional>
#include <mutex>
#include <condition_variable>
#include <memory>

template <typename T>
class BlockingQueue {
private:
    bool nonblock_;
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable not_empty_;
    
public:
    BlockingQueue(bool nonblock = false) : nonblock_(nonblock) {}

    // 入队操作
    void push(const T& value) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(value);
        not_empty_.notify_one();
    }

    // 出队操作
    bool pop(T& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        not_empty_.wait(lock, [this] { return !queue_.empty() || nonblock_; });
        if (queue_.empty()) return false;

        value = queue_.front();
        queue_.pop();
        return true;
    }

    // 解除阻塞在当前队列的线程
    void Cancle() {
        std::lock_guard<std::mutex> lock(mutex_);
        nonblock_ = true;
        not_empty_.notify_all();
    }
};

template <typename T>
class BlockingQueuePro {
private:
    bool nonblock_;
    std::queue<T> producer_queue_;
    std::queue<T> consumer_queue_;
    std::mutex producer_mutex_;
    std::mutex consumer_mutex_;
    std::condition_variable not_empty_;

    int SwapQueue_() {
        std::unique_lock<std::mutex> lock(producer_mutex_);
        not_empty_.wait(lock, [this] { return !producer_queue_.empty() || nonblock_; });
        std::swap(producer_queue_, consumer_queue_);
        return consumer_queue_.size();
    }

public:
    BlockingQueuePro(bool nonblock = false) : nonblock_(nonblock) {}

    // 入队操作
    void push(const T& value) {
        std::lock_guard<std::mutex> lock(producer_mutex_);
        producer_queue_.push(value);
        not_empty_.notify_one();
    }

    // 出队操作
    bool pop(T& value) {
        std::unique_lock<std::mutex> lock(consumer_mutex_);
        if (consumer_queue_.empty() && SwapQueue_() == 0) return false;
        value = consumer_queue_.front();
        consumer_queue_.pop();
        return true;
    }

    // 解除阻塞在当前队列的线程
    void Cancle() {
        std::lock_guard<std::mutex> lock(producer_mutex_);
        nonblock_ = true;
        not_empty_.notify_all();
    }
};

class ThreadPool {
private:
    BlockingQueue<std::function<void()>> task_queue_;  // 任务队列
    // BlockingQueuePro<std::function<void()>> task_queue_;  // 任务队列
    std::vector<std::thread> workers_;  // 工作线程

    void Worker() {
        while (true) {
            std::function<void()> task;
            if (!task_queue_.pop(task)) break;
            task();
        }
    }

public:
    // 构造函数
    explicit ThreadPool(int num_threads) {
        for (std::size_t i = 0; i < num_threads; ++ i) {
            workers_.emplace_back([this]{ Worker(); });
        }
    }

    // 析构函数
    ~ThreadPool() {
        task_queue_.Cancle();
        for (auto& worker: workers_) {
            if (worker.joinable()) worker.join();
        }
    }

    // 发布任务到线程池
    // F 表示一个可调用对象(函数、lambda 表达式、函数对象等)，Args 表示函数对象的参数类型
    // Args... 是一个可变参数模板，表示可以接收任意数量的参数
    template <typename F, typename... Args>
    void Post(F&& f, Args&&... args) {
        auto task = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        task_queue_.push(task);
    }
};
```

`main.cpp`

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>
#include <chrono>
#include "ThreadPool.h"

// 全局计数器，用于统计任务完成的数量
std::atomic<int> task_counter(0);

void Task(int id) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));  // 休眠 100 毫秒，模拟任务执行时间
    std::cout << "Task " << id << " executed by thread " << std::this_thread::get_id() << std::endl;
    ++ task_counter;  // 任务完成，计数器加 1
}

// 生产者线程函数
void Producer(ThreadPool& pool, int producer_id, int num_tasks) {
    for (int i = 0; i < num_tasks; ++ i) {
        int task_id = producer_id * 1000 + i;  // 生成唯一的任务 id
        pool.Post(Task, task_id);  // 提交任务到线程池
        std::cout << "Producer " << producer_id << " posted task " << task_id << std::endl;
    }
}

int main() {
    const int num_producers = 4;  // 生产者线程数量
    const int num_tasks_per_producer = 10;  // 每个生产者提交的任务数量
    const int num_threads_in_pool = 2;  // 线程池中的工作线程数量

    ThreadPool pool(num_threads_in_pool);  // 创建线程池
    std::vector<std::thread> producers;  // 生产者线程集合

    // 启动生产者线程
    for (int i = 0; i < num_producers; ++ i) {
        producers.emplace_back(Producer, std::ref(pool), i, num_tasks_per_producer);
    }

    // 等待所有生产者线程完成
    for (auto& producer : producers) {
        producer.join();
    }

    // 等待所有任务完成
    while (task_counter < num_producers * num_tasks_per_producer) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    std::cout << "All tasks completed. Total tasks executed: " << task_counter << std::endl;

    return 0;
}
```

编译并运行：

```bash
g++ main.cpp -o main -lpthread && ./main > out.txt
```

`./main > out.txt` 输出重定向，如果 `out.txt` 已经存在，则可能会报错

这是可以使用 `./main >! out.txt` 覆盖掉原来的内容，也可以使用 `./main >> out.txt` 在原来的内容后面追加。

>   [Shell 输入/输出重定向](https://www.runoob.com/linux/linux-shell-io-redirections.html)
>
>   [Shell脚本深入教程：Bash高级重定向](https://www.junmajinlong.com/shell/script_course/shell_redirection/index.html)

运行结果：

```text
Producer 0 posted task 0
Producer 0 posted task 1
Producer 0 posted task 2
Producer 0 posted task 3
Producer 0 posted task 4
Producer 0 posted task 5
Producer 0 posted task 6
Producer 0 posted task 7
Producer 0 posted task 8
Producer 0 posted task 9
Producer 1 posted task 1000
Producer 2 posted task 2000
Producer 2 posted task 2001
Producer 2 posted task 2002
Producer 2 posted task 2003
Producer 2 posted task 2004
Producer 2 posted task 2005
Producer 2 posted task 2006
Producer 2 posted task 2007
Producer 2 posted task 2008
Producer 2 posted task 2009
Producer 3 posted task 3000
Producer 3 posted task 3001
Producer 1 posted task 1001
Producer 1 posted task 1002
Producer 1 posted task 1003
Producer 1 posted task 1004
Producer 1 posted task 1005
Producer 1 posted task 1006
Producer 1 posted task 1007
Producer Producer 1 posted task 1008
Producer 1 posted task 1009
3 posted task 3002
Producer 3 posted task 3003
Producer 3 posted task 3004
Producer 3 posted task 3005
Producer 3 posted task 3006
Producer 3 posted task 3007
Producer 3 posted task 3008
Producer 3 posted task 3009
Task 0 executed by thread 137624954074816
Task 1 executed by thread 137624945682112
Task 2 executed by thread 137624954074816
Task 3 executed by thread 137624945682112
Task 2000 executed by thread 137624954074816
Task 4 executed by thread 137624945682112
Task 5 executed by thread 137624954074816
Task 6 executed by thread 137624945682112
Task 7 executed by thread 137624954074816
Task 8 executed by thread 137624945682112
Task 9 executed by thread 137624954074816
Task 1000 executed by thread 137624945682112
Task 3000 executed by thread 137624954074816
Task 2001 executed by thread 137624945682112
Task 2002 executed by thread 137624954074816
Task 2003 executed by thread 137624945682112
Task 2004 executed by thread 137624954074816
Task 2005 executed by thread 137624945682112
Task 2006 executed by thread 137624954074816
Task 2007 executed by thread 137624945682112
Task 2008 executed by thread 137624954074816
Task 2009 executed by thread 137624945682112
Task 1001 executed by thread 137624954074816
Task 3001 executed by thread 137624945682112
Task 3002 executed by thread 137624954074816
Task 1002 executed by thread 137624945682112
Task 1003 executed by thread 137624954074816
Task 1004 executed by thread 137624945682112
Task 1005 executed by thread 137624954074816
Task 1006 executed by thread 137624945682112
Task 1007 executed by thread 137624954074816
Task 1008 executed by thread 137624945682112
Task 1009 executed by thread 137624954074816
Task 3003 executed by thread 137624945682112
Task 3004 executed by thread 137624954074816
Task 3005 executed by thread 137624945682112
Task 3006 executed by thread 137624954074816
Task 3007 executed by thread 137624945682112
Task 3008 executed by thread 137624954074816
Task 3009 executed by thread 137624945682112
All tasks completed. Total tasks executed: 40
```



## 参考资料

[1] [华为海思C++一面：手撕线程池~源码分享](https://www.bilibili.com/video/BV1Rbwhe3Euh)

[2] workflow