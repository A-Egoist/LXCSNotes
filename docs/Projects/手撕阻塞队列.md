# 手撕阻塞队列

## 目标

**阻塞队列**（Blocking Queue）的实现综合了多线程编程中的**同步**与**并发**知识，同时也是理解**生产者-消费者模型**的核心。

阻塞队列通常用于多线程环境中，当队列为空时，尝试取元素的线程会被阻塞；当队列已满时，尝试放元素的线程会被阻塞。



## 设计思路

要实现一个阻塞队列，我们需要考虑如下几个关键组件：

1.   底层容器：用来存储元素，比如 `std::queue` 或 `std::deque`。
2.   一个互斥锁：保护底层容器，防止多个线程同时访问和修改，从而避免数据竞争。
3.   两个条件变量：
     *   一个用于通知消费者：当有新元素加入队列时，通知正在等待的消费者线程。
     *   一个用于通知生产者：当队列有空闲时，通知正在等待的生产者线程。



## 具体实现

阻塞队列实现：

```cpp
#include <queue>
#include <mutex>
#include <condition_variable>
#include <atomic>

template <typename T>
class BlockingQueue {
public:
    BlockingQueue(int max_size = 1024) : MAX_SIZE_(max_size) {}

    bool push(const T& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_producter_.wait(lock, [&]() { return queue_.size() < MAX_SIZE_ || is_stop_; });
        if (is_stop_.load()) {
            return false;
        }
        queue_.push(value);
        cv_consumer_.notify_one();
        return true;
    }

    bool pop(T& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_consumer_.wait(lock, [&]() { return !queue_.empty() || is_stop_; });
        if (is_stop_.load()) {
            return false;
        }
        value = queue_.front();
        queue_.pop();
        cv_producter_.notify_one();
        return true;
    }

    bool empty() {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.empty();
    }

    size_t size() {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.size();
    }

    void stop() {
        is_stop_.store(true);
        cv_producter_.notify_all();
        cv_consumer_.notify_all();
    }

private:
    size_t MAX_SIZE_;
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable cv_producter_;
    std::condition_variable cv_consumer_;
    std::atomic<bool> is_stop_{false};
};
```



阻塞队列+多生产者-多消费者样例测试：

```cpp
#include <queue>
#include <mutex>
#include <condition_variable>
#include <atomic>

#include <thread>
#include <string>
#include <iostream>
#include <chrono>

template <typename T>
class BlockingQueue {
public:
    BlockingQueue(int max_size = 1024) : MAX_SIZE_(max_size) {}

    bool push(const T& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_producter_.wait(lock, [&]() { return queue_.size() < MAX_SIZE_ || is_stop_; });
        if (is_stop_.load()) {
            return false;
        }
        queue_.push(value);
        cv_consumer_.notify_one();
        return true;
    }

    bool pop(T& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_consumer_.wait(lock, [&]() { return !queue_.empty() || is_stop_; });
        if (is_stop_.load()) {
            return false;
        }
        value = queue_.front();
        queue_.pop();
        cv_producter_.notify_one();
        return true;
    }

    bool empty() {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.empty();
    }

    size_t size() {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.size();
    }

    void stop() {
        is_stop_.store(true);
        cv_producter_.notify_all();
        cv_consumer_.notify_all();
    }

private:
    size_t MAX_SIZE_;
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable cv_producter_;
    std::condition_variable cv_consumer_;
    std::atomic<bool> is_stop_{false};
};

BlockingQueue<int> blocking_queue(16);

void worker_producter(std::string name, int value) {
    while (true) {
        std::cout << "生产者[" << name << "] 生产了 " << value << "\n";
        if (blocking_queue.push(value)) {
            std::cout << "生产者[" << name << "] 生产了 " << value << "\n";
        } else {
            break;
        }
    }
}

void worker_consumer(std::string name) {
    while (true) {
        int value;
        if (blocking_queue.pop(value)) {
            std::cout << "消费者[" << name << "] 消费了 " << value << "\n";
        } else {
            break;
        }
    }
}

int main() {
    std::cout << "开始创建子线程\n";
    std::thread t1(worker_producter, "A", 1);
    std::thread t2(worker_producter, "B", 2);
    std::thread t3(worker_consumer, "C");
    std::thread t4(worker_consumer, "D");

    std::this_thread::sleep_for(std::chrono::seconds(1));
    blocking_queue.stop();
    
    if (t1.joinable()) t1.join();
    if (t2.joinable()) t2.join();
    if (t3.joinable()) t3.join();
    if (t4.joinable()) t4.join();
    std::cout << "子线程运行结束\n";

    return 0;
}
```

