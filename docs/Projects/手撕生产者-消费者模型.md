# 手撕生产者-消费者模型



阻塞队列+多生产者-多消费者：

```cpp
#include <queue>
#include <mutex>
#include <condition_variable>
#include <atomic>

#include <thread>
#include <string>
#include <iostream>
#include <chrono>

template <typename T>
class BlockingQueue {
public:
    BlockingQueue(int max_size = 1024) : MAX_SIZE_(max_size) {}

    bool push(const T& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_producter_.wait(lock, [&]() { return queue_.size() < MAX_SIZE_ || is_stop_; });
        if (is_stop_.load()) {
            return false;
        }
        queue_.push(value);
        cv_consumer_.notify_one();
        return true;
    }

    bool pop(T& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_consumer_.wait(lock, [&]() { return !queue_.empty() || is_stop_; });
        if (is_stop_.load()) {
            return false;
        }
        value = queue_.front();
        queue_.pop();
        cv_producter_.notify_one();
        return true;
    }

    bool empty() {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.empty();
    }

    size_t size() {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.size();
    }

    void stop() {
        is_stop_.store(true);
        cv_producter_.notify_all();
        cv_consumer_.notify_all();
    }

private:
    size_t MAX_SIZE_;
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable cv_producter_;
    std::condition_variable cv_consumer_;
    std::atomic<bool> is_stop_{false};
};

BlockingQueue<int> blocking_queue(16);

void worker_producter(std::string name, int value) {
    while (true) {
        std::cout << "生产者[" << name << "] 生产了 " << value << "\n";
        if (blocking_queue.push(value)) {
            std::cout << "生产者[" << name << "] 生产了 " << value << "\n";
        } else {
            break;
        }
    }
}

void worker_consumer(std::string name) {
    while (true) {
        int value;
        if (blocking_queue.pop(value)) {
            std::cout << "消费者[" << name << "] 消费了 " << value << "\n";
        } else {
            break;
        }
    }
}

int main() {
    std::cout << "开始创建子线程\n";
    std::thread t1(worker_producter, "A", 1);
    std::thread t2(worker_producter, "B", 2);
    std::thread t3(worker_consumer, "C");
    std::thread t4(worker_consumer, "D");

    std::this_thread::sleep_for(std::chrono::seconds(1));
    blocking_queue.stop();
    
    if (t1.joinable()) t1.join();
    if (t2.joinable()) t2.join();
    if (t3.joinable()) t3.join();
    if (t4.joinable()) t4.join();
    std::cout << "子线程运行结束\n";

    return 0;
}
```

