# 手撕日志类

使用阻塞队列实现一个支持同步和异步模式的单例模式日志类。

在同步模式下，当用户调用 `log()` 的时候会线程安全的直接写入将 `msg` 写入日志文件。

在异步模式下，当用户调用 `log()` 的时候会将 `msg` 存入阻塞队列中，然后有一个工作线程负责读取阻塞队列中的 `msg` 并将其写入到日志文件中。



文件的打开方式：

1.   `std::ios::ate`: 
2.   `std::ios::app`: 



## 代码实现

单例模式模板：

```cpp
class Singleon {
public:
    static Singleon& getInstance() {
        static Singleon instance;
        return instance;
    }
private:
    Singleon() {}
    ~Singleon() {}
    Singleon(const Singleon&) = delete;
    Singleon& operator=(const Singleon&) = delete;
    Singleon(Singleon&&) = delete;
    Singleon& operator=(Singleon&&) = delete;
};
```

日志类实现：

`logger.hpp`：

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <thread>
#include "blocking_queue.hpp"

#define LOG_INFO(msg) Logger::getInstance().log("INFO", msg)
#define LOG_DEBUG(msg) Logger::getInstance().log("DEBUG", msg)
#define LOG_WARNING(msg) Logger::getInstance().log("WARNING", msg)
#define LOG_ERROR(msg) Logger::getInstance().log("ERROR", msg)


class Logger {
public:
    static Logger& getInstance() {
        static Logger instance;
        return instance;
    }

    void init(const std::string& filename, bool async, int max_queue_size) {
        std::cout << "Logger is initializing\n";
        bool expected = false;
        if (!is_init_.compare_exchange_strong(expected, true)) return;

        async_ = async;
        log_file_.open(filename, std::ios::app);  // ate 模式或者 app 模式
        if (!log_file_.is_open()) {
            std::cerr << "Cannot open log file: " << filename << "\n";
        }

        if (async_) {
            buffer_ = new BlockingQueue<std::string>(max_queue_size);
            write_thread_ = std::thread(&Logger::writeLog, this);
            // write_thread_ = std::thread([this]() { writeLog(); });
            // write_thread_ = std::thread([&]() { writeLog(); });
        }

        std::cout << "Logger initialized\n";
    }

    void log(const std::string& level, const std::string& message) {
        if (!is_init_.load()) return;  // 没有初始化

        std::string msg = level + ": " + message + "\n";
        if (async_) {
            buffer_->push(msg);
        } else {
            std::lock_guard<std::mutex> lock(mutex_);
            log_file_ << msg;
            log_file_.flush();
        }
    }

    void stop() {
        bool expected = true;
        if (!is_init_.compare_exchange_strong(expected, false)) return;  // 已经停止或者没有初始化

        if (async_ && buffer_ != nullptr) {
            buffer_->stop();

            if (write_thread_.joinable()) write_thread_.join();

            delete buffer_;
            buffer_ = nullptr;
        }

        if (log_file_.is_open()) log_file_.close();
    }

private:
    std::ofstream log_file_;  // 日志文件
    BlockingQueue<std::string>* buffer_;  // 日志缓存区
    std::thread write_thread_;  // 工作线程
    std::atomic<bool> is_init_{false};  // 标志是否初始化，用于线程安全
    bool async_;  // 异步表示，true 表示异步，false 表示同步
    std::mutex mutex_;  // 日志锁，在同步模式使用

    void writeLog() {
        // 异步模式执行的任务
        std::string msg;
        while (buffer_->pop(msg)) {
            log_file_ << msg;
            log_file_.flush();  // 写一次就刷新，会影响性能
        }
    }

    Logger() {}
    ~Logger() {
        stop();
    }
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
    Logger(Logger&&) = delete;
    Logger& operator=(Logger&&) = delete;
};
```

测试代码：
```cpp
#include <iostream>
#include "logger.hpp"

// 线程工作函数
void worker_thread(int id, int log_count) {
    for (int i = 0; i < log_count; ++i) {
        // 使用宏进行日志记录
        LOG_INFO("[Thread " + std::to_string(id) + "] Log Message: " + std::to_string(i));
        // 模拟一些工作负载
        // std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}

int main() {
    // 定义日志文件名
    const std::string log_filename = "app_test.log";

    // --- Part 1: Asynchronous Test (推荐模式) ---
    std::cout << "--- Starting ASYNC Logger Test ---\n";
    
    // 1. 初始化异步 Logger
    Logger::getInstance().init(log_filename, true, 16); 

    // 2. 创建并运行多线程
    const int num_threads = 5;
    const int logs_per_thread = 500;
    std::thread threads[num_threads];
    
    auto start_time = std::chrono::high_resolution_clock::now();

    for (int i = 0; i < num_threads; ++i) {
        threads[i] = std::thread(worker_thread, i, logs_per_thread);
    }

    // 3. 等待所有线程完成日志入队
    for (int i = 0; i < num_threads; ++i) {
        threads[i].join();
    }
    
    auto end_time = std::chrono::high_resolution_clock::now();
    long long duration_ms = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();
    
    long long total_logs = (long long)num_threads * logs_per_thread;
    std::cout << "All producer threads finished in " << duration_ms << "ms.\n";
    std::cout << "Total logs generated: " << total_logs << ".\n";

    // 4. 在程序退出前，显式调用 stop()，安全地关闭异步线程并刷新队列
    // 如果不手动调用，析构函数也会自动调用 stop()
    Logger::getInstance().stop();

    std::cout << "--- ASYNC Logger Test Complete ---\n\n";
    
    return 0;
}
```

