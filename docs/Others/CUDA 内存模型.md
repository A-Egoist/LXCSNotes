# CUDA 内存模型

CUDA 可编程内存类型：

* 寄存器(Registers)
* 共享内存(Shared Memory)
* 本地内存(Local Memory)
* 常量内存(Constant Memory)
* 纹理内存(Texture Memory)
* 全局内存(Global Memory)

上述各种内存都有自己的作用域，生命周期和缓存行为。一个核函数中的每个线程都有自己私有的本地内存。一个线程块有自己的共享内存，对同一线程块内所有线程可见，其内容持续线程块的整个生命周期。所有线程都可以访问全局内存。所有线程都能访问只读内存：常量内存和纹理内存。全局内存，常量内存和纹理内存空间有不同的用途。纹理内存为各种数据布局提供了不同的寻址模式和滤波模式。对于一个应用来说，全局内存，常量内存和纹理内存有相同的生命周期。

<img src="https://amonologue-image-bed.oss-cn-chengdu.aliyuncs.com/2024/202410062340818.jpeg" style="zoom: 80%;" />





### 寄存器(Registers)

寄存器变量对于每个线程来说都是私有的，一个核函数通常使用寄存器来保存需要频繁访问的线程私有变量。寄存器变量与核函数的生命周期相同，一旦核函数执行完毕，就不能对寄存器变量进行访问了。

如果一个核函数使用了超过硬件限制数量的寄存器，则会用本地内存代替多占用的寄存器。

### 本地内存(Local Memory)

核函数中符合存储在寄存器中但不能进入被核函数分配的寄存器空间中的变量将溢出到在本地内存中，编译器可能存放在本地内存中的变量有以下几种：

- 在编译时使用未知索引引用的本地数组
- 可能会占用大量寄存器空间的较大本地结构体或数组
- 任何不满足核函数寄存器限定条件的变量

本地内存实质上是和全局内存一样在同一块存储区域当中的，其访问特点——高延迟，低带宽。



### 共享内存(Shared Memory)

在核函数中使用如下修饰符的变量，存放在共享内存中：

```c
__shared__
```

共享内存是片上内存，与本地内存或全局内存相比，其拥有更高的带宽和更低的延迟。每一个 SM 都有一定数量的由线程块分配的共享内存，但如果过渡使用共享内存，会限制活跃线程束的数量。

共享内存在核函数内声明，生命周期和线程块一致，线程块运行开始，此块的共享内存被分配，当此块结束，则共享内存被释放。

共享内存是线程之间相互通信的基本方式。一个块内的线程通过使用共享内存中的数据可以相互合作。访问共享内存必须同步使用如下调用。

```c
void __syncthreads();
```



### 常量内存(Constant Memory)

常量内存驻留在设备内存中，每个 SM 都有专用的常量内存缓存，常量内存修饰符：

```c
__constant__
```

常量变量必须在全局空间内和所有核函数之外进行声明。

### 纹理内存(Texture Memory)

纹理内存驻留在设备内存中，在每个 SM 的只读缓存中缓存，纹理内存是通过指定的缓存访问的全局内存，只读缓存包括硬件滤波的支持，它可以将浮点插入作为读取过程中的一部分来执行，纹理内存是对二维空间局部性的优化。
总的来说纹理内存设计目的应该是为了 GPU 本职工作显示设计的，但是对于某些特定的程序可能效果更好，比如需要滤波的程序，可以直接通过硬件完成。

### 全局内存(Global Memory)

GPU 上最大的内存空间，延迟最高，使用最常见的内存，Global 指的是作用域和生命周期，一般在主机端代码里定义，也可以在设备端定义，不过需要加修饰符，只要不销毁，是和应用程序同生命周期的。全局内存对应于设备内存，一个是逻辑表示，一个是硬件表示。

全局内存可以动态声明，或者静态声明，可以用下面的修饰符在设备代码中静态的声明一个变量：

```c
__device__
```

### GPU 缓存

GPU 上的四种缓存：

* 一级缓存

* 二级缓存

* 只读常量缓存

* 只读纹理缓存

每个 SM 都有一个一级缓存，所有 SM 共享一个二级缓存。一级和二级缓存的作用都是被用来存储本地内存和全局内存中的数据，也包括寄存器溢出的部分。

## 1 内存访问模式

### 1.1 对齐与合并访问



